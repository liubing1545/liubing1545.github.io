<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Elasticsearch</title>
    <url>/2021/08/04/Elasticsearch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p>Lucene是Apache软件基金会Jakarta项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做全文索引和搜索。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。但Lucene只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来进行应用。比如Elasticsearch And Solr。</p>
<h2 id="下载与启动"><a href="#下载与启动" class="headerlink" title="下载与启动"></a>下载与启动</h2><p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>bin文件夹下，elasticsearch.bat</p>
<p>9300端口为Elasticsearch集群间组件的通信端口，9200端口为浏览器访问的http协议RESTful端口。</p>
<h2 id="Elasticsearch的配置"><a href="#Elasticsearch的配置" class="headerlink" title="Elasticsearch的配置"></a>Elasticsearch的配置</h2><p>配置文件：config/elasticsearch.yml</p>
<p>所有配置项参考官方Settings，均可通过配置文件或命令行配置。对于相同的配置项，命令行配置会覆盖配置文件中的配置。命令行参数均以-E开头，如：-Ecluster.name=my_cluster -Enode.name=node_1</p>
<p>大部分配置项都可以在集群运行过程中在线更改，参考官方Cluster Update Settings API。配置文件中只需要配置结点为了加入集群而必须要提前配置的项即可，类似node.name、cluster.name和network.host等。</p>
<h2 id="Elasticsearch的目录结构"><a href="#Elasticsearch的目录结构" class="headerlink" title="Elasticsearch的目录结构"></a>Elasticsearch的目录结构</h2><table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>默认值</th>
<th align="left">配置参数</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td>ES的安装目录</td>
<td>$ES_HOME</td>
<td align="left">-</td>
</tr>
<tr>
<td>bin</td>
<td>elasticsearch (用于启动node)，elasticsearch-plugin (用于安装插件)</td>
<td>$ES_HOME/bin</td>
<td align="left">-</td>
</tr>
<tr>
<td>conf</td>
<td>配置文件路径，包含elasticsearch.yml等配置文件</td>
<td>$ES_HOME/conf</td>
<td align="left">path.conf</td>
</tr>
<tr>
<td>data</td>
<td>数据文件路径（存储每个索引分配到该结点上的分片数据），可配置多个值</td>
<td>$ES_HOME/data</td>
<td align="left">path.data</td>
</tr>
<tr>
<td>logs</td>
<td>日志文件路径</td>
<td>$ES_HOME/logs</td>
<td align="left">path.logs</td>
</tr>
<tr>
<td>plugins</td>
<td>插件路径，每个插件分别存放在单独的子目录中</td>
<td>$ES_HOME/plugins</td>
<td align="left">-</td>
</tr>
<tr>
<td>repo</td>
<td>Shared file system repository locations. Can hold multiple locations. A file system repository can be placed in to any subdirectory of any directory specified here</td>
<td>-</td>
<td align="left">path.repo</td>
</tr>
<tr>
<td>script</td>
<td>Location of script files.</td>
<td>$ES_HOME/scripts</td>
<td align="left">path.scripts</td>
</tr>
</tbody></table>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Elasticsearch是一个高度可扩展（highly scalable）的全文检索和分析引擎。它可用于大数据的存储，并以接近实时（NRT, Near Realtime）的速度进行检索和分析。</p>
<p>常见的使用场景示例：</p>
<ol>
<li> 在线商品search或autocomplete，ES存储所有商品目录和库存信息</li>
<li> 挖掘日志或交易数据，获得一些统计、趋势等信息。这种场景可以使用logstash组件将数据feed到ES</li>
<li> 做价格提醒，如用户可以指定“当某个指定的商品价格低于$X时提醒他”，此时可以收集价格信息到ES中，然后用ES的反向检索（reverse-search）特性Percolator来匹配查询推送提醒</li>
<li> 需要在大量数据上做快速调查、分析、可视化、解决特定问题，可以用ES存储数据，用Kibana建立自定义的dashbord进行可视化展现。也可以使用聚合功能做一些复杂的BI查询</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>Cluster必须有一个唯一的name，默认是elasticsearch，每个node只能属于一个cluster。</p>
<p>Cluster Name示例：logging-dev, logging-stage, logging-prod</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>存储数据、提供索引和查询能力，name默认是启动时分配的一个UUID标识，也可自定义，通过指定cluster name将node加入某个集群。单独机器启动时默认新建一个单结点集群（cluster name默认为elasticsearch）。</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>必须指定name，全小写，这个name用于search、update、delete该索引上的文档。</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>每个Index上可以定义Type，可根据需要命名，如：user/blog/comments</p>
<p>（Elasticsearch 7.X中，Type的概念已经被删除了）</p>
<h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>JSON格式，虽然物理上存储在index中，但需关联index中的一个type。</p>
<h3 id="Shards-amp-Replicas"><a href="#Shards-amp-Replicas" class="headerlink" title="Shards &amp; Replicas"></a>Shards &amp; Replicas</h3><p>一个index可能很大，一个结点存不了或者会响应太慢，ES可以将index分片，每个分片可以存储在不同的Node上，提供完整的index功能：</p>
<ol>
<li>创建索引时可以指定shards数量</li>
<li>可以水平分割，分Partition存储</li>
<li>可以垂直分割，允许跨shards的并行操作，能够提高性能和吞吐</li>
<li>shard的分布机制以及如何聚合搜索结果由ES完成，对用户是透明的</li>
<li>为了保证高可用，ES会存储shards的复本，称为Replicas</li>
<li>index创建后，可以指定replicas的数量，但不能修改shards的数量</li>
<li>ES默认每个index分为5个shard，每个shard存储1份replicas，即两结点的集群每个index默认会有10个shard</li>
<li>每个shard是一个Lucene Index，限制大小：Integer.MAX_VALUE - 128 = 2,147,483,519</li>
<li>查看shards使用API：<a href="http://ip.addres:port/_cat/shards">http://ip.addres:port/_cat/shards</a></li>
</ol>
<h2 id="Elasticsearch的REST-API"><a href="#Elasticsearch的REST-API" class="headerlink" title="Elasticsearch的REST API"></a>Elasticsearch的REST API</h2><p>Elasticsearch提供的REST API可以进行如下操作：</p>
<ol>
<li>检查集群、结点、索引的状态信息</li>
<li>管理集群、结点、索引的数据和元数据</li>
<li>对索引执行CRUD和search操作</li>
<li>执行高级检查功能：分页、排序、过滤、聚合等</li>
</ol>
<p>示例：</p>
<p>Cluster Health: <code>GET http://ip.address:port/_cat/health?v</code></p>
<p>Node Info: <code>GET http://ip.address:port/_cat/nodes?v</code></p>
<p>List All Indices: <code>GET http://ip.address:port/_cat/indices?v</code></p>
<p>Index Operation:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本操作：&lt;REST Verb&gt; /&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span><br><span class="line">PUT /customer</span><br><span class="line">PUT /customer/external/1</span><br><span class="line">&#123;&quot;name&quot;: &quot;John Doe&quot;&#125;</span><br><span class="line">GET /customer/external/1</span><br><span class="line">DELETE /customer</span><br><span class="line"></span><br><span class="line"># 向同一个URL PUT不同的数据，可以更新替换doc数据</span><br><span class="line"># 如：更新ID=1的doc的name字段，同时增加一个age字段</span><br><span class="line">POST /customer/external/1/_update?pretty</span><br><span class="line">&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125; &#125;</span><br><span class="line"># 使用script更新age，如下的ctx._source表示当前将要被修改的文档对象</span><br><span class="line">POST /customer/external/1/_update?pretty</span><br><span class="line">&#123; &quot;script&quot; : &quot;ctx._source.age += 5&quot; &#125;</span><br><span class="line"># 每次Update只能更新一个doc，后续会提供类似SQL的where语句一样的批量更新的功能</span><br><span class="line"></span><br><span class="line"># 也可不指定doc的ID，由ES随机生成doc id</span><br><span class="line">POST /customer/external?pretty</span><br><span class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 删除某个文档</span><br><span class="line">DELETE /customer/external/2?pretty</span><br><span class="line"># 如果要删除全部文档，更有效的方式是直接删除整个index</span><br></pre></td></tr></table></figure>

<p>Bulk API:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 批处理-添加两个文档</span><br><span class="line">POST /customer/external/_bulk?pretty</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line"></span><br><span class="line"># 批处理-更新文档1删除文档2</span><br><span class="line">POST /customer/external/_bulk?pretty</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line"># 批处理遇到某个文档出错会继续执行，最后给出执行结果</span><br></pre></td></tr></table></figure>

<p>Search API:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search?q=*&amp;sort=account_number:asc&amp;pretty</span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;] // 返回指定字段</span><br><span class="line">  // &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Match Query:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;account_number&quot;: 20 &#125; &#125;</span><br><span class="line">  // &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125; // address中包含mill的doc</span><br><span class="line">  // &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125; // address包含mill或lane的doc</span><br><span class="line">  // &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125; // address中包含mill lane的doc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bool Query:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [ // address中同时包含mill和lane的doc</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [ // address中包含mill或lane的doc</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [ // address中既不含mill也不含lane的doc</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 以上must/should/must_not可以在bool查询中混用</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>conda</tag>
        <tag>tensorflow</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>MultiHash和Base58</title>
    <url>/2020/05/23/MultiHash%E5%92%8CBase58/</url>
    <content><![CDATA[<h2 id="MultiHash和Base58"><a href="#MultiHash和Base58" class="headerlink" title="MultiHash和Base58"></a>MultiHash和Base58</h2><h3 id="MultiHash"><a href="#MultiHash" class="headerlink" title="MultiHash"></a>MultiHash</h3><p>目前IPFS使用SHA2-256的加密方式，目前来说比较安全，但随着科技发展，说不定哪天就会被破解。因此IPFS在制定协议时，采用了MultiHash这种方式，可扩展支持多种HASH算法。如果未来改用了别的算法，用的仍然是MultiHash，也就保持了加密方式的持续性。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>HASH算法编码</li>
<li>HASH值长度（字节数）</li>
<li>HASH值</li>
</ul>
<p>SHA2-256的编码为0x12，其Hash摘要长度为32字节（十六进制为0x20）。</p>
<p>所以将 <strong>1220</strong> 添加到所有的Hash值前。</p>
<h3 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h3><p>Base64有一些缺点，就是某些字符容易混淆，比如<strong>O</strong>和<strong>0</strong>等。很容易将字符串认错，造成阅读上的障碍。Base58将Hash值压缩，并且剔除了干扰字符。</p>
<p>因此<strong>1220</strong>开头的Hash值都被编码成了<strong>Qm</strong>开头。</p>
<p>这就是ipfs add时，返回的CID都是Qm开头的原因。</p>
]]></content>
      <tags>
        <tag>ipfs</tag>
        <tag>MultiHash</tag>
        <tag>Base58</tag>
      </tags>
  </entry>
  <entry>
    <title>ServiceWorker尝试</title>
    <url>/2020/05/22/ServiceWorker%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<h2 id="ServiceWorker尝试"><a href="#ServiceWorker尝试" class="headerlink" title="ServiceWorker尝试"></a>ServiceWorker尝试</h2><h3 id="node12-14-0下安装-x73-x71-108-105-116-x65-51-64-x33-46-49-46-49-x33-失败"><a href="#node12-14-0下安装-x73-x71-108-105-116-x65-51-64-x33-46-49-46-49-x33-失败" class="headerlink" title="node12.14.0下安装&#x73;&#x71;&#108;&#105;&#116;&#x65;&#51;&#64;&#x33;&#46;&#49;&#46;&#49;&#x33;失败"></a>node12.14.0下安装<a href="mailto:&#x73;&#x71;&#108;&#105;&#116;&#x65;&#51;&#64;&#x33;&#46;&#49;&#46;&#49;&#x33;">&#x73;&#x71;&#108;&#105;&#116;&#x65;&#51;&#64;&#x33;&#46;&#49;&#46;&#49;&#x33;</a>失败</h3><blockquote>
<p>download (403): <a href="https://mapbox-node-binary.s3.amazonaws.com/sqlite3/v3.1.13/node-v72-win3">https://mapbox-node-binary.s3.amazonaws.com/sqlite3/v3.1.13/node-v72-win3</a> 2-x64.tar.gz</p>
<p>binaries not found for <a href="mailto:&#x73;&#x71;&#108;&#105;&#x74;&#x65;&#x33;&#64;&#51;&#x2e;&#49;&#x2e;&#49;&#x33;">&#x73;&#x71;&#108;&#105;&#x74;&#x65;&#x33;&#64;&#51;&#x2e;&#49;&#x2e;&#49;&#x33;</a> and <a href="mailto:&#110;&#111;&#100;&#x65;&#x40;&#x31;&#x32;&#46;&#49;&#52;&#46;&#48;">&#110;&#111;&#100;&#x65;&#x40;&#x31;&#x32;&#46;&#49;&#52;&#46;&#48;</a> (node-v72 ABI) (falling back to source compile with node-gyp)</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>安装nvm <a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install 8.9.3</span><br><span class="line">nvm use 8.9.3</span><br></pre></td></tr></table></figure>

<p>配置nvm，如果需要proxy的话就配置proxy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm proxy http://$proxy-url/</span><br><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<p>再次安装即能成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>node</tag>
        <tag>Service Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm降级node安装sqlite3</title>
    <url>/2020/05/22/nvm%E9%99%8D%E7%BA%A7node%E5%AE%89%E8%A3%85sqlite3/</url>
    <content><![CDATA[<h2 id="nvm降级node安装sqlite3"><a href="#nvm降级node安装sqlite3" class="headerlink" title="nvm降级node安装sqlite3"></a>nvm降级node安装sqlite3</h2><h3 id="node12-14-0下安装-x73-113-108-x69-x74-101-x33-64-51-46-49-x2e-x31-51-失败"><a href="#node12-14-0下安装-x73-113-108-x69-x74-101-x33-64-51-46-49-x2e-x31-51-失败" class="headerlink" title="node12.14.0下安装&#x73;&#113;&#108;&#x69;&#x74;&#101;&#x33;&#64;&#51;&#46;&#49;&#x2e;&#x31;&#51;失败"></a>node12.14.0下安装<a href="mailto:&#x73;&#113;&#108;&#x69;&#x74;&#101;&#x33;&#64;&#51;&#46;&#49;&#x2e;&#x31;&#51;">&#x73;&#113;&#108;&#x69;&#x74;&#101;&#x33;&#64;&#51;&#46;&#49;&#x2e;&#x31;&#51;</a>失败</h3><blockquote>
<p>download (403): <a href="https://mapbox-node-binary.s3.amazonaws.com/sqlite3/v3.1.13/node-v72-win3">https://mapbox-node-binary.s3.amazonaws.com/sqlite3/v3.1.13/node-v72-win3</a> 2-x64.tar.gz</p>
<p>binaries not found for <a href="mailto:&#x73;&#113;&#x6c;&#x69;&#116;&#x65;&#51;&#x40;&#51;&#46;&#x31;&#x2e;&#49;&#51;">&#x73;&#113;&#x6c;&#x69;&#116;&#x65;&#51;&#x40;&#51;&#46;&#x31;&#x2e;&#49;&#51;</a> and <a href="mailto:&#x6e;&#111;&#x64;&#x65;&#x40;&#49;&#x32;&#46;&#49;&#52;&#46;&#48;">&#x6e;&#111;&#x64;&#x65;&#x40;&#49;&#x32;&#46;&#49;&#52;&#46;&#48;</a> (node-v72 ABI) (falling back to source compile with node-gyp)</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>安装nvm <a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm install 8.9.3</span><br><span class="line">nvm use 8.9.3</span><br></pre></td></tr></table></figure>

<p>配置nvm，如果需要proxy的话就配置proxy</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm proxy http://$proxy-url/</span><br><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<p>再次安装即能成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Worker</title>
    <url>/2020/04/28/Service%20Worker/</url>
    <content><![CDATA[<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Service Worker本质上也是浏览器缓存资源用的，只不过他不仅仅是cache，也是通过worker的方式来进一步优化。</p>
<p>他基于h5的web worker，所以绝对不会阻碍当前js线程的执行，sw最重要的工作原理就是</p>
<ol>
<li><p>后台线程：独立于当前网页线程；</p>
</li>
<li><p>网络代理：在网页发起请求时代理，来缓存文件；</p>
</li>
</ol>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>sw 是基于 HTTPS 的，因为service worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。如果是本地调试的话，localhost是可以的。</p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>PWA是Progressive Web App的英文缩写， 翻译过来就是渐进式增强WEB应用。</p>
<h4 id="PWA中所包含的核心功能及特性"><a href="#PWA中所包含的核心功能及特性" class="headerlink" title="PWA中所包含的核心功能及特性"></a>PWA中所包含的核心功能及特性</h4><ol>
<li>Web App Manifest</li>
<li>Service Worker</li>
<li>Cache API缓存</li>
<li>Push &amp; Notification 推送与通知</li>
<li>Background Sync 后台同步</li>
<li>响应式设计</li>
</ol>
<p>在service worker忠，可以监听install、activate，message，fetch，sync，push等事件。</p>
<h3 id="WorkBox"><a href="#WorkBox" class="headerlink" title="WorkBox"></a>WorkBox</h3><p>在service worker中通过监听事件，然后编写对应逻辑，缓存文件都不是很容易。并且webpack build之后，js名称随时会变。因此chrome推出了workbox框架。</p>
<p><strong>workbox 是用于向web应用程序添加离线支持的JavaScript库。</strong></p>
<p>在wokbox对象中，包含很多模块，比如 workbox.routing模块，workbox.precaching模块，workbox.strategies模块，workbox.expiration模块等等，它们分别负责处理不同的逻辑。</p>
<ol>
<li>workbox缓存/预缓存</li>
<li>workbox路由</li>
<li>workbox插件</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000019281388?utm_source=tag-newest">workbox的使用介绍</a></p>
<p>另外npm中也已经有这个包了<a href="https://link.jianshu.com/?t=https://www.npmjs.com/package/web-pwa">https://www.npmjs.com/package/web-pwa</a> ，可以玩玩。</p>
]]></content>
      <tags>
        <tag>Service Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个简单的区块链</title>
    <url>/2020/04/20/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h2 id="如何搭建一个简单的区块链"><a href="#如何搭建一个简单的区块链" class="headerlink" title="如何搭建一个简单的区块链"></a>如何搭建一个简单的区块链</h2><h3 id="bitcoin"><a href="#bitcoin" class="headerlink" title="bitcoin"></a>bitcoin</h3><p>Cypherpunk宣言</p>
<h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>八卦协议，流行病协议。</p>
<p>比特币使用的gossip protocol，Cassandra和redis Cluster都采用了gossip protocol以达到自动发现。以太坊使用的Kademlia。</p>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>RSA非对称加密</p>
<p>ECC椭圆曲线加密</p>
<p>签名过程：私钥用于签名，公钥用于验证签名</p>
<p>交易过程：公钥用于加密，私钥用于解密</p>
<h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>PoW</p>
<p>PoS</p>
<p>DPos</p>
<h3 id="blockchain"><a href="#blockchain" class="headerlink" title="blockchain"></a>blockchain</h3><p>挖矿的本质是记账。</p>
]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS-Cluster客户端构建</title>
    <url>/2020/03/25/IPFS-Cluster%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="IPFS-Cluster客户端构建"><a href="#IPFS-Cluster客户端构建" class="headerlink" title="IPFS-Cluster客户端构建"></a>IPFS-Cluster客户端构建</h2><h2 id="安装windows构建插件"><a href="#安装windows构建插件" class="headerlink" title="安装windows构建插件"></a>安装windows构建插件</h2><p>需要使用管理员权限安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install –global –production windows-build-tools</span><br></pre></td></tr></table></figure>

<p>保证有python2.7的编译环境</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 --single-branch https://github.com/caorushizi/oss-client.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd oss-client</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npx cross-env npm_config_electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot; npm_config_electron_custom_dir=&quot;7.1.9&quot; npm install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>react</tag>
        <tag>node</tag>
        <tag>electron</tag>
        <tag>blockchain</tag>
        <tag>ipfs</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS-Cluster搭建(ubuntu)</title>
    <url>/2020/03/14/IPFS-Cluster%E6%90%AD%E5%BB%BA(ubuntu)/</url>
    <content><![CDATA[<h2 id="IPFS-Cluster搭建-ubuntu"><a href="#IPFS-Cluster搭建-ubuntu" class="headerlink" title="IPFS-Cluster搭建(ubuntu)"></a>IPFS-Cluster搭建(ubuntu)</h2><h2 id="Update-Linux-packages-and-dependencies"><a href="#Update-Linux-packages-and-dependencies" class="headerlink" title="Update Linux packages and dependencies:"></a>Update Linux packages and dependencies:</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y upgrade</span><br></pre></td></tr></table></figure>

<h2 id="Install-IPFS"><a href="#Install-IPFS" class="headerlink" title="Install IPFS"></a>Install IPFS</h2><p>准备好的go-ipfs资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf go-ipfs_v0.4.23_linux-amd64.tar.gz</span><br><span class="line">cd go-ipfs</span><br><span class="line">sudo ./install.sh //安装文件自动mv /usr/local/bin</span><br><span class="line">ipfs init //ipfs初始化</span><br><span class="line">ipfs version</span><br></pre></td></tr></table></figure>

<h2 id="Creating-a-Private-network"><a href="#Creating-a-Private-network" class="headerlink" title="Creating a Private network"></a>Creating a Private network</h2><p>拷贝准备好的swarm.key到集群各个节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp swarm.key ~/.ipfs/swarm.key</span><br></pre></td></tr></table></figure>

<h2 id="Bootstrapping-IPFS-nodes"><a href="#Bootstrapping-IPFS-nodes" class="headerlink" title="Bootstrapping IPFS nodes"></a>Bootstrapping IPFS nodes</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs bootstrap rm --all</span><br><span class="line">ipfs bootstrap add /ip4/启动节点的ip地址/tcp/4001/ipfs/启动节点的id的hash</span><br></pre></td></tr></table></figure>

<p>也可以配置环境变量强制为private mode:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LIBP2P_FORCE_PNET=1</span><br></pre></td></tr></table></figure>

<h2 id="Run-IPFS-daemon-as-a-service-in-the-background"><a href="#Run-IPFS-daemon-as-a-service-in-the-background" class="headerlink" title="Run IPFS daemon as a service in the background"></a>Run IPFS daemon as a service in the background</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/systemd/system/ipfs.service</span><br></pre></td></tr></table></figure>

<p>添加配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=IPFS Daemon</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/bin/ipfs daemon --enable-namesys-pubsub</span><br><span class="line">User=$rootuser</span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>Apply新service。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable ipfs</span><br><span class="line">sudo systemctl start ipfs</span><br><span class="line">sudo systemctl status ipfs</span><br></pre></td></tr></table></figure>

<h2 id="Deploying-IPFS-Cluster"><a href="#Deploying-IPFS-Cluster" class="headerlink" title="Deploying IPFS-Cluster"></a>Deploying IPFS-Cluster</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf ipfs-cluster-service_v0.12.1_linux-amd64.tar.gz</span><br><span class="line">tar -zxf ipfs-cluster-ctl_v0.12.1_linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="Generate-and-set-up-CLUSTER-SECRET-variable"><a href="#Generate-and-set-up-CLUSTER-SECRET-variable" class="headerlink" title="Generate and set up CLUSTER_SECRET variable"></a>Generate and set up CLUSTER_SECRET variable</h2><p>在主节点，生成cluster-secret</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLUSTER_SECRET=$(od -vN 32 -An -tx1 /dev/urandom | tr -d &#x27; \n&#x27;) </span><br><span class="line">echo $CLUSTER_SECRET</span><br></pre></td></tr></table></figure>

<p>把生成的cluster_secret设置入所有节点的.bashrc中再source</p>
<h2 id="Run-IPFS-Cluster-daemon-as-a-service"><a href="#Run-IPFS-Cluster-daemon-as-a-service" class="headerlink" title="Run IPFS-Cluster daemon as a service"></a>Run IPFS-Cluster daemon as a service</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/systemd/system/ipfs-cluster.service</span><br></pre></td></tr></table></figure>

<p>主节点添加配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=IPFS-Cluster Daemon</span><br><span class="line">Requires=ipfs</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target ipfs</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/$rootuser/ipfs-tools/ipfs-cluster-service/ipfs-cluster-service daemon</span><br><span class="line">User=$rootuser</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>子节点添加配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=IPFS-Cluster Daemon</span><br><span class="line">Requires=ipfs</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target ipfs</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/home/$rootuser/ipfs-tools/ipfs-cluster-service/ipfs-cluster-service daemon --bootstrap /ip4/38.91.120.173/tcp/9096/ipfs/12D3KooWSL6aP7UqkV8YruT99htjjdHQq4rHFvsRTrmdpSnt9cSL</span><br><span class="line">User=$rootuser</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>Apply新service。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable ipfs-cluster</span><br><span class="line">sudo systemctl start ipfs-cluster</span><br><span class="line">sudo systemctl status ipfs-cluster</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>ipfs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS-Cluster搭建</title>
    <url>/2020/03/14/IPFS-Cluster%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="IPFS-Cluster搭建"><a href="#IPFS-Cluster搭建" class="headerlink" title="IPFS-Cluster搭建"></a>IPFS-Cluster搭建</h2><p>私有网络集群允许IPFS节点只连接到拥有共享密钥的其他对等节点，网络中的节点不响应来自网络外节点的通信请求。IPFS-Cluster是一个独立的应用程序和一个CLI客户端 ，它跨一组IPFS守护进程分配、复制和跟踪pin。它使用基于Raft一致性算法来协调存储，将数据集合分布到参与的节点上。</p>
<p>目前在搭建分布式存储系统时，需要将一个peer上存储的文件同步备份到所有集群上的其他的peer上，或者对集群的节点管理，就需要IPFS-Cluster来实现。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://dist.ipfs.io/#go-ipfs">ipfs官网</a></p>
<p>进入官网选择合适的版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dist.ipfs.io/ipfs-cluster-ctl/v0.12.1/ipfs-cluster-ctl_v0.12.1_linux-amd64.tar.gz</span><br><span class="line">wget https://dist.ipfs.io/ipfs-cluster-service/v0.12.1/ipfs-cluster-service_v0.12.1_linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>



<h2 id="安装ipfs-cluster-service"><a href="#安装ipfs-cluster-service" class="headerlink" title="安装ipfs-cluster-service"></a>安装ipfs-cluster-service</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf ipfs-cluster-service_v0.12.1_linux-amd64.tar.gz</span><br><span class="line">cd ipfs-cluster-service</span><br><span class="line">./ipfs-cluster-service init //初始化</span><br></pre></td></tr></table></figure>

<p>初始化之后会生成两个文件 </p>
<blockquote>
<p>.ipfs-cluster/service.json</p>
<blockquote>
<p>含有secret和监听端口，需要把secret配置到其他节点的service.json里，保证一样。</p>
</blockquote>
</blockquote>
<blockquote>
<p>.ipfs-cluster/identity.json</p>
<blockquote>
<p>含有cluster的节点id</p>
</blockquote>
</blockquote>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>主节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ipfs-cluster-service daemon &amp;</span><br></pre></td></tr></table></figure>

<p>其他节点启动–bootstrap添加主节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ipfs-cluster-service daemon --bootstrap /ip4/$主节点ip/tcp/9096/ipfs/$cluster id</span><br></pre></td></tr></table></figure>



<h2 id="安装ipfs-cluster-ctl"><a href="#安装ipfs-cluster-ctl" class="headerlink" title="安装ipfs-cluster-ctl"></a>安装ipfs-cluster-ctl</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf ipfs-cluster-ctl_v0.12.1_linux-amd64.tar.gz</span><br><span class="line">cd ipfs-cluster-ctl</span><br><span class="line">./ipfs-cluster-ctl peers ls</span><br></pre></td></tr></table></figure>



<h2 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h2><p>一定需要保证所有服务器的9094端口、9095端口、9096端口开放input的安全组。</p>
<ul>
<li>9094-HTTP API endpoint</li>
<li>9095-IPFS proxy endpoint</li>
<li>9096-Cluster swarm</li>
</ul>
]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>ipfs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS搭建(windows节点)</title>
    <url>/2020/03/13/IPFS%E6%90%AD%E5%BB%BA(windows%E8%8A%82%E7%82%B9)/</url>
    <content><![CDATA[<h2 id="IPFS搭建-windows节点"><a href="#IPFS搭建-windows节点" class="headerlink" title="IPFS搭建(windows节点)"></a>IPFS搭建(windows节点)</h2><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://dist.ipfs.io/#go-ipfs">ipfs官网</a></p>
<p>进入官网选择合适的版本。<strong>Windows Binary</strong></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在下载好的binary文件夹里执行以下命令后，会在根目录生成一个.ipfs的文件夹存储节点数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs.exe init //初始化ipfs</span><br><span class="line">ipfs bootstrap rm -all //删除默认的bootstrap设置</span><br></pre></td></tr></table></figure>

<p>将集群中之前生成好的swarm.key文件拷贝进**~.ipfs**文件夹下</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>添加启动节点地址到当前节点的bootstrap列表中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs bootstrap add /ip4/启动节点的ip地址/tcp/4001/ipfs/启动节点的id的hash</span><br></pre></td></tr></table></figure>

<p>一定需要保证所有服务器的4001端口和5001端口开放input的安全组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon &amp; //启动，后台运行</span><br><span class="line">ipfs bootstrap list  //查看ipfs bootstrap列表</span><br></pre></td></tr></table></figure>

<p>在各个节点查看别的节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs swarm peers</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>ipfs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS搭建</title>
    <url>/2020/03/06/IPFS%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="IPFS搭建"><a href="#IPFS搭建" class="headerlink" title="IPFS搭建"></a>IPFS搭建</h2><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p><a href="https://dist.ipfs.io/#go-ipfs">ipfs官网</a></p>
<p>进入官网选择合适的版本。<strong>go-ipfs_v0.4.23_linux-amd64.tar.gz</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf  go-ipfs.tar.gz</span><br><span class="line">cd go-ipfs</span><br><span class="line">./install.sh //安装文件自动mv /usr/local/bin</span><br><span class="line">ipfs init //ipfs初始化</span><br></pre></td></tr></table></figure>

<p><a href="https://dl.google.com/go/go1.14.windows-amd64.msi">下载go</a></p>
<p>我下载的是windows版本。</p>
<h2 id="私有网络"><a href="#私有网络" class="headerlink" title="私有网络"></a>私有网络</h2><h3 id="清除缺省启动节点"><a href="#清除缺省启动节点" class="headerlink" title="清除缺省启动节点"></a>清除缺省启动节点</h3><p>默认会连接进ipfs的公链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs bootstrap rm --all</span><br></pre></td></tr></table></figure>

<h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Kubuxu/go-ipfs-swarm-key-gen.git //下载秘钥生成工具源码</span><br><span class="line">go build ipfs-swarm-key-gen/main.go //编译得到main.exe</span><br><span class="line">main.exe&gt;swarm.key //执行得到秘钥文件swarm.key</span><br></pre></td></tr></table></figure>

<h3 id="拷贝秘钥"><a href="#拷贝秘钥" class="headerlink" title="拷贝秘钥"></a>拷贝秘钥</h3><p>将生成的swarm.key文件拷贝进所有的节点服务器中**~.ipfs**文件夹下</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>选择一台稳定的公网ip地址为启动节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs id //查看该节点生成的hash</span><br></pre></td></tr></table></figure>

<p>添加该节点地址到所有节点的bootstrap列表中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs bootstrap add /ip4/启动节点的ip地址/tcp/4001/ipfs/启动节点的id的hash</span><br></pre></td></tr></table></figure>

<p>启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs daemon &amp; //启动，后台运行</span><br><span class="line">ipfs bootstrap list  //查看ipfs bootstrap列表</span><br></pre></td></tr></table></figure>

<p>在各个节点查看别的节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs swarm peers</span><br></pre></td></tr></table></figure>

<h2 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipfs add xxx.png //上传到私链上，会返回hash码</span><br><span class="line">ipfs get hash码 // 下载</span><br></pre></td></tr></table></figure>

<h2 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h2><p>一定需要保证所有服务器的4001端口、5001端口、8080端口开放input的安全组。</p>
<ul>
<li>4001-与其他节点通信</li>
<li>5001-API server</li>
<li>8080-Gateway server</li>
</ul>
]]></content>
      <tags>
        <tag>blockchain</tag>
        <tag>ipfs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Peergos安装记</title>
    <url>/2020/03/02/Peergos%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Peergos安装记"><a href="#Peergos安装记" class="headerlink" title="Peergos安装记"></a>Peergos安装记</h2><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>作者在github里记录，为了跑tests，需要安装ant-optional这个插件，根据调查，ant-optional这个插件只有debian/ubuntu提供。因此准备一台ubuntu的机器。</p>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-11-jdk</span><br><span class="line">sudo apt-get install ant</span><br></pre></td></tr></table></figure>

<ul>
<li>ubuntu：Ubuntu 18.04.3 LTS</li>
<li>java：openjdk 11.0.6</li>
<li>ant：1.10.5</li>
</ul>
<h2 id="下载peergos"><a href="#下载peergos" class="headerlink" title="下载peergos"></a>下载peergos</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Peergos/Peergos.git</span><br><span class="line">git clone https://github.com/Peergos/web-ui.git</span><br></pre></td></tr></table></figure>

<h2 id="网络要求"><a href="#网络要求" class="headerlink" title="网络要求"></a>网络要求</h2><p>必须翻墙！！！</p>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>根据github执行各种ant命令，启动后台就是下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ant update_and_run</span><br></pre></td></tr></table></figure>
<p>考虑有两种方式运行web-ui。</p>
<ol>
<li>在ubuntu客户端通过ide运行整体系统。</li>
<li>前后端分离部署，前端通过命令ant ui来build静态资源文件，要修改vue的代码，在post/get等http请求中加入8000端口的后端url。通过nginx代理别的端口即可。</li>
</ol>
]]></content>
      <tags>
        <tag>ipfs</tag>
        <tag>git</tag>
        <tag>peergos</tag>
      </tags>
  </entry>
  <entry>
    <title>gitignore更新后，删除未来不需要管控的程序</title>
    <url>/2019/07/22/gitignore%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E5%88%A0%E9%99%A4%E6%9C%AA%E6%9D%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AE%A1%E6%8E%A7%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="提交更新后的gitignore文件，删除本地缓存再提交"><a href="#提交更新后的gitignore文件，删除本地缓存再提交" class="headerlink" title="提交更新后的gitignore文件，删除本地缓存再提交"></a>提交更新后的gitignore文件，删除本地缓存再提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop+spark分布式环境搭建</title>
    <url>/2019/05/27/hadoop+spark%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Hadoop整体框架"><a href="#Hadoop整体框架" class="headerlink" title="Hadoop整体框架"></a>Hadoop整体框架</h2><p>Hadoop由HDFS、MapReduce、HBase、Hive和ZooKeeper等成员组成，其中最基础最重要的两种组成元素为底层用于存储集群中所有存储节点文件的文件系统HDFS（Hadoop Distributed File System）和上层用来执行MapReduce程序的MapReduce引擎。</p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS架构采用主从架构（master/slave）。一个典型的HDFS集群包含一个NameNode节点和多个DataNode节点。NameNode节点负责整个HDFS文件系统中的文件的元数据保管和管理，集群中通常只有一台机器上运行NameNode实例，DataNode节点保存文件中的数据，集群中的机器分别运行一个DataNode实例。在HDFS中，NameNode节点被称为名称节点，DataNode节点被称为数据节点。DataNode节点通过心跳机制与NameNode节点进行定时的通信。</p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map/Reduce"></a>Map/Reduce</h3><p>MapReduce是一种编程模型，用于大规模数据集的并行运算。Map（映射）和Reduce（化简），采用分而治之思想，先把任务分发到集群多个节点上，并行计算，然后再把计算结果合并，从而得到最终计算结果。多节点计算，所涉及的任务调度、负载均衡、容错处理等，都由MapReduce框架完成，不需要编程人员关心这些内容。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备了3台CentOS 6.10 64bit云服务器，1台做master NameNode主节点，2台做DataNode节点。</p>
<h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p>在3台服务器上的/etc/hosts，追加以下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.0.189 master worker0 namenode</span><br><span class="line">192.168.0.233 worker1 datanode1</span><br><span class="line">192.168.0.117 worker2 datanode2</span><br></pre></td></tr></table></figure>
<p>统一hosts文件，可以让主机通过host名字来识别彼此。<br><strong><label style="color:red">ip为内网ip，不能配公网ip，不然hadoop启动异常。9000端口未出现在监听中</label></strong></p>
<h3 id="ssh互信-免密登录"><a href="#ssh互信-免密登录" class="headerlink" title="ssh互信(免密登录)"></a>ssh互信(免密登录)</h3><p>在master节点执行以下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &#x27;&#x27; #生成公钥</span><br><span class="line">scp /root/.ssh/id_rsa.pub root@worker1:/root/.ssh/id_rsa.pub.master #从master节点拷贝id_rsa.pub到worker主机上,并且改名为id_rsa.pub.master</span><br><span class="line">scp /root/.ssh/id_rsa.pub root@worker2:/root/.ssh/id_rsa.pub.master</span><br><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>在node节点执行以下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub.master &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul>
<li>Java 1.8.0_211</li>
<li>Hadoop 3.1.2</li>
<li>Spark 2.4.3</li>
<li>Scala 2.11.12</li>
</ul>
<h3 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.rpm</span><br><span class="line">rpm ivh jdk-8u112-linux-x64.rpm</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop安装"><a href="#Hadoop安装" class="headerlink" title="Hadoop安装"></a>Hadoop安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz</span><br><span class="line">tar -xvf hadoop-3.1.2.tar.gz</span><br><span class="line">mv hadoop-3.1.2 /opt</span><br></pre></td></tr></table></figure>

<h3 id="Spark安装"><a href="#Spark安装" class="headerlink" title="Spark安装"></a>Spark安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.3/spark-2.4.3-bin-hadoop2.7.tgz</span><br><span class="line">tar -xvf spark-2.4.3-bin-hadoop2.7.tgz</span><br><span class="line">mv spark-2.4.3-bin-hadoop2.7 /opt</span><br></pre></td></tr></table></figure>

<h3 id="Scala安装"><a href="#Scala安装" class="headerlink" title="Scala安装"></a>Scala安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O &quot;scala-2.12.8.rpm&quot; &quot;https://downloads.lightbend.com/scala/2.12.8/scala-2.12.8.rpm&quot;</span><br><span class="line">rpm ivh scala-2.12.8.rpm</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置</p>
<h3 id="设定环境变量"><a href="#设定环境变量" class="headerlink" title="设定环境变量"></a>设定环境变量</h3><p>在/etc/profile中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">java home</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211-amd64/</span><br><span class="line"><span class="meta">#</span><span class="bash">scala home</span></span><br><span class="line">export SCALA_HOME=/usr/share/scala</span><br><span class="line"><span class="meta">#</span><span class="bash">hadoop enviroment</span></span><br><span class="line">export HADOOP_HOME=/opt/hadoop-3.1.2/</span><br><span class="line">export PATH=&quot;$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH&quot;</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line"><span class="meta">#</span><span class="bash">spark enviroment</span></span><br><span class="line">export SPARK_HOME=/opt/spark-2.4.3-bin-hadoop2.7/</span><br><span class="line">export PATH=&quot;$SPARK_HOME/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h3><p>在**$HADOOP_HOME/etc/hadoop/hadoop-env.sh**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211-amd64/</span><br></pre></td></tr></table></figure>

<p>在**$HADOOP_HOME/etc/hadoop/workers**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker1</span><br><span class="line">worker2</span><br></pre></td></tr></table></figure>

<p>在**$HADOOP_HOME/etc/hadoop/core-site.xml**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">         &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;131072&lt;/value&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;/opt/hadoop-3.1.2/tmp&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>在**$HADOOP_HOME/etc/hadoop/hdfs-site.xml**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;master:50090&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;file:/opt/hadoop-3.1.2/hdfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;file:/opt/hadoop-3.1.2/hdfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure>

<p>在**$HADOOP_HOME/etc/hadoop/mapred-site.xml**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">          &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;master:10020&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">          &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;master:19888&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>在**$HADOOP_HOME/etc/hadoop/yarn-site.xml**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">          &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">           &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</span><br><span class="line">           &lt;value&gt;master:8032&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">          &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;master:8030&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">         &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;master:8031&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">         &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;master:8033&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">         &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;master:8088&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>格式化<strong>namenode</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure>
<p><strong><label style="color:red">若多次格式化namenode，需先清空hadoop/tmp下文件，再格式化</label></strong></p>
<h3 id="配置Spark"><a href="#配置Spark" class="headerlink" title="配置Spark"></a>配置Spark</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure>

<p>在**$SPARK_HOME/conf/spark-env.sh**中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export SCALA_HOME=/usr/share/scala</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211-amd64/</span><br><span class="line">export SPARK_MASTER_IP=master</span><br><span class="line">export SPARK_WORKER_MEMORY=1g</span><br><span class="line">export HADOOP_CONF_DIR=/opt/hadoop-3.1.2/etc/hadoop</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp slaves.template slaves</span><br></pre></td></tr></table></figure>
<p>在**$SPARK_HOME/conf/slaves**文件中配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">worker1</span><br><span class="line">worker2</span><br></pre></td></tr></table></figure>

<h2 id="启动-关闭集群"><a href="#启动-关闭集群" class="headerlink" title="启动/关闭集群"></a>启动/关闭集群</h2><p>启动脚本start-cluster.sh如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -e &quot;\033[31m ========Start The Cluster======== \033[0m&quot;</span><br><span class="line">echo -e &quot;\033[31m Starting Hadoop Now !!! \033[0m&quot;</span><br><span class="line">/opt/hadoop-3.1.2/sbin/start-all.sh</span><br><span class="line">echo -e &quot;\033[31m Starting Spark Now !!! \033[0m&quot;</span><br><span class="line">/opt/spark-2.4.3-bin-hadoop2.7/sbin/start-all.sh</span><br><span class="line">echo -e &quot;\033[31m The Result Of The Command \&quot;jps\&quot; :  \033[0m&quot;</span><br><span class="line">jps</span><br><span class="line">echo -e &quot;\033[31m ========END======== \033[0m&quot;</span><br></pre></td></tr></table></figure>

<p>关闭脚本stop-cluster.sh如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -e &quot;\033[31m ===== Stoping The Cluster ====== \033[0m&quot;</span><br><span class="line">echo -e &quot;\033[31m Stoping Spark Now !!! \033[0m&quot;</span><br><span class="line">/opt/spark-2.4.3-bin-hadoop2.7/sbin/stop-all.sh</span><br><span class="line">echo -e &quot;\033[31m Stopting Hadoop Now !!! \033[0m&quot;</span><br><span class="line">/opt/hadoop-3.1.2/sbin/stop-all.sh</span><br><span class="line">echo -e &quot;\033[31m The Result Of The Command \&quot;jps\&quot; :  \033[0m&quot;</span><br><span class="line">jps</span><br><span class="line">echo -e &quot;\033[31m ======END======== \033[0m&quot;</span><br></pre></td></tr></table></figure>

<h3 id="JPS查看进程"><a href="#JPS查看进程" class="headerlink" title="JPS查看进程"></a>JPS查看进程</h3><p>master节点，jps查看进程信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20069 Jps</span><br><span class="line">8118 NameNode</span><br><span class="line">9096 Worker</span><br><span class="line">8392 SecondaryNameNode</span><br><span class="line">9003 Master</span><br><span class="line">8655 ResourceManager</span><br></pre></td></tr></table></figure>

<p>node节点，jps查看进程信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4210 DataNode</span><br><span class="line">7362 Jps</span><br><span class="line">4328 NodeManager</span><br></pre></td></tr></table></figure>

<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="could-only-be-written-to-0-of-the-1-minReplication-nodes"><a href="#could-only-be-written-to-0-of-the-1-minReplication-nodes" class="headerlink" title="could only be written to 0 of the 1 minReplication nodes."></a>could only be written to 0 of the 1 minReplication nodes.</h3><p>这个问题是由于使用hadoop namenode -format 格式化多次，导致spaceID不一致造成的，解决方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash stop-cluster.sh</span><br><span class="line">rm -rf /tmp/*</span><br><span class="line">rm -rf /opt/hadoop-3.1.2/tmp/*</span><br><span class="line">hadoop namenode -format</span><br><span class="line">bash start-cluster.sh</span><br></pre></td></tr></table></figure>

<h3 id="ipc-Client-Retrying-connect-to-server-localhost-127-0-0-1"><a href="#ipc-Client-Retrying-connect-to-server-localhost-127-0-0-1" class="headerlink" title="ipc.Client: Retrying connect to server: localhost/127.0.0.1"></a>ipc.Client: Retrying connect to server: localhost/127.0.0.1</h3><p>配置logger为debugger模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_ROOT_LOGGER=DEBUG,console</span><br></pre></td></tr></table></figure>
<p>查看具体报错信息</p>
<h3 id="Unable-to-load-native-hadoop-library"><a href="#Unable-to-load-native-hadoop-library" class="headerlink" title="Unable to load native-hadoop library"></a>Unable to load native-hadoop library</h3><p>去hadoop文件夹里找到libhadoop文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd libhadoop.so</span><br></pre></td></tr></table></figure>

<h3 id="libc-so-6-version-GLIBC2-14-not-found"><a href="#libc-so-6-version-GLIBC2-14-not-found" class="headerlink" title="libc.so.6 version GLIBC2.14 not found"></a>libc.so.6 version GLIBC2.14 not found</h3><p>查看系统glibc版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /lib64/libc.so.6 |grep GLIBC_</span><br></pre></td></tr></table></figure>
<p>如果列表中系统支持的glibc的最高版本是GLIBC_2.12，则做升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</span><br><span class="line">tar zxf glibc-2.14.tar.gz</span><br><span class="line">cd glibc-2.14 &amp;&amp; mkdri build</span><br><span class="line">cd build &amp;&amp; ../configure --prefix=/opt/glibc-2.14</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>安装成功之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /lib64/libc.so.6</span><br><span class="line">ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出问题，执行下面</span></span><br><span class="line">LD_PRELOAD=/opt/glibc-2.14/lib/libc-2.14.so ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6</span><br></pre></td></tr></table></figure>

<h3 id="There-are-0-datanode-s-running-and-no-node-s-are-excluded-in-this-operation"><a href="#There-are-0-datanode-s-running-and-no-node-s-are-excluded-in-this-operation" class="headerlink" title="There are 0 datanode(s) running and no node(s) are excluded in this operation"></a>There are 0 datanode(s) running and no node(s) are excluded in this operation</h3><p>这个错误是node没有正常设置。其中有可能涉及两个原因：</p>
<ul>
<li>主机在/etc/hosts里配置的是公网ip，改成内网ip。</li>
<li>hadoop在master和node中的配置保持一样。</li>
</ul>
]]></content>
      <tags>
        <tag>hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>aws爬梯子</title>
    <url>/2019/01/17/aws%E7%88%AC%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="ubuntu下亲测有效"><a href="#ubuntu下亲测有效" class="headerlink" title="ubuntu下亲测有效"></a>ubuntu下亲测有效</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>aws</tag>
        <tag>梯子</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链挖矿</title>
    <url>/2018/10/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h2 id="本地私链创世区块"><a href="#本地私链创世区块" class="headerlink" title="本地私链创世区块"></a>本地私链创世区块</h2><p>在当前文件夹下创建genesis.json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0x0000000000000042&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;extraData&quot;</span>: <span class="string">&quot;0x00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0x80000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x01&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mixhash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;coinbase&quot;</span>: <span class="string">&quot;0x3333333333333333333333333333333333333333&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span>: &#123;     &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;chainId&quot;</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;homesteadBlock&quot;</span>:<span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;eip155Block&quot;</span>:<span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;eip158Block&quot;</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数名|描述</span><br><span class="line">---:|--:</span><br><span class="line">chainId|指定了独立的区块链网络 ID。网络 ID 在连接到其他节点的时候会用到，以太坊公网的网络 ID 是 <span class="number">1</span>，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络 ID。不同 ID 网络的节点无法相互连接。</span><br><span class="line">HomesteadBlock|当设置为<span class="number">0</span>表示使用Homestead发布该链。</span><br><span class="line">difficulty|设置设置当前区块的难度，越大挖矿就越难。</span><br><span class="line">alloc|用来预置账号以及账号的以太币数量。</span><br><span class="line">coinbase|矿工账号。</span><br><span class="line">timestamp|设置创世块的时间戳。</span><br><span class="line">parentHash|上一个区块的hash，创世块就为<span class="number">0</span>。</span><br><span class="line">extraData|附加信息。</span><br><span class="line">gasLimit|该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和。</span><br><span class="line">mixhash|与nonce配合用于挖矿，由上一个区块的一部分生成的hash。</span><br><span class="line">nonce|nonce就是一个<span class="number">64</span>位随机数，用于挖矿。</span><br><span class="line"></span><br><span class="line">## 初始化创始区块</span><br><span class="line"></span><br><span class="line">### geth</span><br><span class="line">geth是以太坊的客户端程序。全称是Go-ethereum，是用go语言编写的。目前比较常用。</span><br><span class="line">[官网下载地址](https:<span class="comment">//www.ethereum.org/cli)</span></span><br><span class="line"></span><br><span class="line">### 初始化genesis.json文件</span><br><span class="line">```shell</span><br><span class="line">geth --datadir <span class="string">&quot;D:\github\blockchain-learn\tmpPrivate&quot;</span> init <span class="string">&quot;D:\github\blockchain-learn\tmpPrivate\genesis.json&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建私链"><a href="#创建私链" class="headerlink" title="创建私链"></a>创建私链</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geth --datadir &quot;D:\github\blockchain-learn\tmpPrivate&quot; --nodiscover console 2&gt;&gt;geth.log</span><br><span class="line">personal.neweAccount(&quot;liubing&quot;)</span><br><span class="line">eth.accounts</span><br></pre></td></tr></table></figure>

<h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">miner.start()</span><br><span class="line">eth.getBalance(eth.accounts[0])</span><br><span class="line">eth.blockNumber</span><br><span class="line">miner.stop()</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链入门</title>
    <url>/2018/10/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="区块链的特点"><a href="#区块链的特点" class="headerlink" title="区块链的特点"></a>区块链的特点</h2><ul>
<li>匿名</li>
<li>不可篡改和加密安全性</li>
<li>无须信任系统</li>
<li>分布式去中心化</li>
<li>交易透明</li>
</ul>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>以太坊=区块链技术+智能合约</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约可以是一个众筹合约，也可以是一个数学公式，或者是一个完全的随机数。</p>
<h3 id="智能合约实践"><a href="#智能合约实践" class="headerlink" title="智能合约实践"></a>智能合约实践</h3><h4 id="browser-solidity"><a href="#browser-solidity" class="headerlink" title="browser-solidity"></a>browser-solidity</h4><p><a href="https://ethereum.github.io/browser-solidity/#version=soljson-v0.4.9+commit.364da425.js">官网</a></p>
<h4 id="最简单的智能合约"><a href="#最简单的智能合约" class="headerlink" title="最简单的智能合约"></a>最简单的智能合约</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.9</span>;</span><br><span class="line">contract DemoTypes &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a</span>) <span class="title">returns</span> (<span class="params">uint b</span>) </span>&#123;</span><br><span class="line">    uint result = a * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>※目前使用的solidity版本是0.4.9<br><img src="http://obksgg9lx.bkt.clouddn.com/solidity-simple.png" alt="solidity-simple"></p>
<ol>
<li>点击create会将智能合约部署到区块链的网络上（内存上）</li>
<li>trasaction/execution cost代表create一个智能合约所消耗的成本，单位为gas。gas和ether币有一个兑换关系。</li>
<li>合约名字DemoTypes注册在了一个地址上，则说明该合约已被挖矿出来了。</li>
<li>输入100，点击f按钮，进行计算得800。</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>构建python的多并发分布式系统</title>
    <url>/2018/06/27/%E6%9E%84%E5%BB%BApython%E7%9A%84%E5%A4%9A%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="IO密集型的应对"><a href="#IO密集型的应对" class="headerlink" title="IO密集型的应对"></a>IO密集型的应对</h3><p>我们一直致力于采用flask（纯python编写的轻量级web框架）来构建快速开发的微服务应用，并将其应用于工作中项目中。<br>部署时，采用Gunicorn或者uWSGI作为http服务器，因其支持gevent和monkey_patch，立刻就能使同步的web框架获得数倍的性能提升。（*注 gevent对标准I/O函数做了monkey_patch，把它们变成了异步。并且gevent有greenlet对象能够被用于并发执行。）   </p>
<h3 id="CPU密集型的应对"><a href="#CPU密集型的应对" class="headerlink" title="CPU密集型的应对"></a>CPU密集型的应对</h3><p>然而真实的应用场景下，无论是CPU密集型运算或者是庞大的I/O操作，都会对服务器主机造成相当大的负担。<br>比如在我们当前的项目里，有一个很重要的模块需要做算法进行复杂的数学运算。在运算过程中服务器会跑满cpu，并且运算时间很长，大概70秒才可以做完一次处理。如果单纯的将http服务器的worker提升至服务器cpu数量，多并发的request数量也会及其有限，并且压上去的request越多，导致阻塞的时间就会越长，不仅用户体验不好，而且超过了nginx配置的最大连接时间，也会报错。（<em>注 如果架构中使用了nginx做反向代理的话）<br>那么我们将问题梳理一下。在CPU密集型应用中，如何提升服务器性能？（</em>注 IO密集型的问题，已经采用了Gunicorn或者uWSGI的http服务器帮我们单纯应对了。）<br>CPU密集型的问题，我们采用了celery，redis（也可以采用rabbitmq)，及multiprocessing来解决。<br>首先我们将CPU密集型的运算从同步处理中拉出来，做成单个的任务模块，扔进消息队列里，然后异步返回给客户端。<br>其次将服务器主机集群都注册成统一的消息中间件和任务结果存储地址。这样在运行过程中可以根据任务的多少，动态的可插拔式的添加分布式系统的节点，或者删除节点。<br>最后对于单节点应用，我们采用了multiporcessing做分核处理，比如单主机单进程一个CPU跑满大概需要70秒，分成4核做并行处理，则会大概花18秒左右跑出结果。<br>这样，基于微服务的可扩展的多并发分布式系统就构建完成了。其他开发语言的拆分过程思想同理。    </p>
]]></content>
      <tags>
        <tag>celery</tag>
        <tag>python</tag>
        <tag>多并发</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>npm Error! ENOENT no such file or directory .dezalgo.DELETE&#39;</title>
    <url>/2018/06/11/npm%20Error!%20ENOENT%20no%20such%20file%20or%20directory%20.dezalgo.DELETE&#39;/</url>
    <content><![CDATA[<h2 id="这是npm5-6-0的bug"><a href="#这是npm5-6-0的bug" class="headerlink" title="这是npm5.6.0的bug"></a>这是npm5.6.0的bug</h2><p>更新升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm@4.6.1</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/48351466/npm-error-enoent-no-such-file-or-directory-dezalgo-delete">stackoverflow的回答</a></p>
]]></content>
      <tags>
        <tag>npm</tag>
        <tag>dezalgo</tag>
      </tags>
  </entry>
  <entry>
    <title>multiprocessing的并行方式</title>
    <url>/2018/05/24/multiprocessing%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>multiprocessing模块让你使用基于进程和基于线程的并行处理，在队列上共享任务，以及在进程间共享数据。它主要是集中于单机多核的并行（对多机并行来说，有更好的选择）。<br>一个很普遍的用法就是针对CPU密集型的问题，在一个进程集上并行化一个任务。</p>
<h2 id="并行运算"><a href="#并行运算" class="headerlink" title="并行运算"></a>并行运算</h2><ul>
<li>避免共享状态会让并行运算变得简单很多。</li>
<li>每一个进程需要和其他进程来通信的话，那么通信开销将减慢整体的性能。</li>
</ul>
<p>Python中的线程是OS原生的，它们被全局解释锁(GIL)所束缚，所以同一时刻只有一个线程可以被交互。因此Python都会并行一定数量的进程，每一个进程都有私有的内存空间与GIL。如果需要共享状态，就需要增加一些通信的开销。</p>
<h2 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h2><ul>
<li>用进程或者池对象来并行化一个CPU密集型任务。</li>
<li>用dummy模块在线程池中并行化一个I/O密集型任务。</li>
<li>由队列来共享任务。</li>
<li>在并行工作者之间共享状态，包括字节、原生数据类型、字典和列表。</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个当前进程的forked拷贝，创建了一个新的进程标识符，在OS中以一个独立的子进程运行。</p>
<h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>包装了进程和线程。在工作者线程池中共享了工作块并返回聚合后的结果。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>一个FIFP（先进先出）的队列允许多个生产者和消费者。</p>
<h3 id="管理者"><a href="#管理者" class="headerlink" title="管理者"></a>管理者</h3><p>一个单向或双向的在两个进程间的通信渠道。</p>
<h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><p>允许在进程派生后，在父子进程间共享原生数据类型（整数型、浮点型和字节型）</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>锁和信号量在进程间同步。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool, Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slp</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;received: %s&quot;</span> % (a)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	pool = Pool(processes=<span class="number">4</span>)</span><br><span class="line">	start_time = time.clock()</span><br><span class="line">	d_l = []</span><br><span class="line">	p_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">		async_result = pool.apply_async(slp, [i,])</span><br><span class="line">		p_list.append(async_result)</span><br><span class="line">		<span class="comment"># d_l.append(async_result.get())</span></span><br><span class="line">	pool.close()</span><br><span class="line">	pool.join()</span><br><span class="line">	<span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">		d_l.append(p.get())</span><br><span class="line">	<span class="comment"># p_list = []</span></span><br><span class="line">	<span class="comment"># for i in range(0, 4):</span></span><br><span class="line">	<span class="comment">#     p = Process(target=slp)</span></span><br><span class="line">	<span class="comment">#     p.start()</span></span><br><span class="line">	<span class="comment">#     p_list.append(p)</span></span><br><span class="line">	<span class="comment"># for p in p_list:</span></span><br><span class="line">	<span class="comment">#     p.join()</span></span><br><span class="line">	end_time = time.clock()</span><br><span class="line">	duration = <span class="built_in">round</span>(end_time - start_time, <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;time: %s&#x27;</span> % duration</span><br><span class="line">	<span class="built_in">print</span> d_l</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">received: 0</span><br><span class="line">received: 1</span><br><span class="line">received: 2</span><br><span class="line">received: 3</span><br><span class="line">time: 2.12</span><br><span class="line">[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>multiprocessing</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>gevent的异步方式</title>
    <url>/2018/05/23/gevent%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>gevent是基于协程的高性能Python网络库，相比Twisted、Stackless等，gevent使用libev事件循环，因此速度很快、性能很好，使用greenlet提供高层的同步API，因此非常轻量。<br>作者曾经是另一个Python网络库Eventlet的开发者之一，2009年因 为Eventlet无法满足项目需要，他决定另外开发一个更轻量的库，这就是gevent。某种意义上，gevent是从Eventlet项目派生出来的。    </p>
<h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><ul>
<li>gevent对标准I/O函数做了猴子补丁，把它们变成了异步。</li>
<li>并且gevent有greenlet对象能够被用于并发执行。</li>
</ul>
<h3 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h3><p>greenlet是一种协程。gevent的调度器在I/O等待期间使用一个事件循环在所有的greenlets间来回切换，而不是用多个CPU来运行它们。<br>gevent通过使用wait函数来设法尽可能透明化地处理事件循环。wait函数将启动一个事件循环，直到所有的greenlets结束。<br>greenlet由gevent.spawn(func, para)来创建，func是需要执行的函数，para是func的参数。一旦声明的函数执行完成，它的值就会包含在greenlet的value域中。    </p>
<h3 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h3><p>Monkey Patch就是在运行时对已有的代码进行修改，达到hot patch的目的。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">url</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;GET: %s&#x27;</span> % url)</span><br><span class="line">	headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;</span><br><span class="line">	r = requests.get(url, headers = headers)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d bytes received from %s.&#x27;</span> % (r.status_code, url))</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">	gevent.spawn(f, <span class="string">&#x27;https://www.baidu.com&#x27;</span>), </span><br><span class="line">	gevent.spawn(f, <span class="string">&#x27;https://www.sina.com&#x27;</span>),</span><br><span class="line">	gevent.spawn(f, <span class="string">&#x27;http://www.douban.com&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(venv2) E:\github\concurrent&gt;python gevent2.py</span><br><span class="line">GET: https://www.baidu.com</span><br><span class="line">GET: https://www.sina.com</span><br><span class="line">GET: http://www.douban.com</span><br><span class="line">200 bytes received from https://www.baidu.com.</span><br><span class="line">200 bytes received from http://www.douban.com.</span><br><span class="line">200 bytes received from https://www.sina.com.</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在部署web app的时候，用一个支持gevent的WSGI服务器，立刻就获得了数倍的性能提升。</p>
]]></content>
      <tags>
        <tag>gevent</tag>
        <tag>多并发</tag>
      </tags>
  </entry>
  <entry>
    <title>tornado的异步方式</title>
    <url>/2018/05/22/tornado%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Tornado是Facebook主要为HTTP客户端和服务器端开发的异步I/O包。Tornado主要应对的是I/O密集型应用，Tornado可以使用协程和回调两种方式。<br>Tornado 优秀的大并发处理能力得益于它的 web server 从底层开始就自己实现了一整套基于 epoll 的单线程异步架构（其他 python web 框架的自带 server 基本是基于 wsgi 写的简单服务器，并没有自己实现底层结构）。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>ioloop 的实现基于 epoll ，那么什么是 epoll？ epoll 是Linux内核为处理大批量文件描述符而作了改进的 poll 。<br>那么什么又是 poll ？ 首先，我们回顾一下， socket 通信时的服务端，当它接受（ accept ）一个连接并建立通信后（ connection ）就进行通信，而此时我们并不知道连接的客户端有没有信息发完。 这时候我们有两种选择：</p>
<ol>
<li>一直在这里等着直到收发数据结束；</li>
<li>每隔一定时间来看看这里有没有数据；</li>
</ol>
<p>第二种办法要比第一种好一些，多个连接可以统一在一定时间内轮流看一遍里面有没有数据要读写，看上去我们可以处理多个连接了，这个方式就是 poll / select 的解决方案。     看起来似乎解决了问题，但实际上，随着连接越来越多，轮询所花费的时间将越来越长，而服务器连接的 socket 大多不是活跃的，所以轮询所花费的大部分时间将是无用的。为了解决这个问题， epoll 被创造出来，它的概念和 poll 类似，不过每次轮询时，他只会把有数据活跃的 socket 挑出来轮询，这样在有大量连接时轮询就节省了大量时间。</p>
<h2 id="tornado-ioloop"><a href="#tornado-ioloop" class="headerlink" title="tornado.ioloop"></a>tornado.ioloop</h2><p>ioloop 实际上是对 epoll 的封装，并加入了一些对上层事件的处理和 server 相关的底层处理。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_coroutine</span>(<span class="params">url</span>):</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = <span class="keyword">yield</span> http_client.fetch(url)</span><br><span class="line">    <span class="comment">#为了返回值，python2中需要生成一个特殊的异常；在python3.3以后直接用return</span></span><br><span class="line">    <span class="keyword">raise</span> gen.Return(response.body)</span><br></pre></td></tr></table></figure>
<ul>
<li>@gen.coroutine 和 yield 搭配使用，代表的是协成。</li>
<li>yield之后挂起耗时操作，耗时操作完成时从挂起的位置接着往下执行。</li>
<li>Tornado的协成是由python的generators来支持的。</li>
</ul>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous_fetch</span>(<span class="params">url, callback</span>):</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_response</span>(<span class="params">response</span>):</span></span><br><span class="line">        callback(response.body)</span><br><span class="line">    http_client.fetch(url, callback=handle_response)</span><br></pre></td></tr></table></figure>
<ul>
<li>http_client第二个参数callback指定了回调函数。</li>
<li>多重的显式的回调容易引起“回调地狱”。</li>
</ul>
]]></content>
      <tags>
        <tag>多并发</tag>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title>刷票</title>
    <url>/2018/05/18/%E5%88%B7%E7%A5%A8/</url>
    <content><![CDATA[<p>给小朋友投票，拉微信朋友圈的朋友点赞什么的好麻烦啊。索性把分享的页面url拉到浏览器上研究一下，发条http post把data拿出来，直接post到目标地址不就ok了。开搞。</p>
<h2 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">get_cookie=requests.get(<span class="string">&quot;https://aa.rrxiu.cc/v/4uj43w?vt=1&amp;from_code=3c2953a3680daf86bfdb76cef13d2572&amp;guid97=d8c3e2e1aee2be5b35e571711865189f-162498&amp;from=timeline&amp;isappinstalled=0&quot;</span>)</span><br><span class="line">data=&#123;<span class="string">&#x27;wsiteGuid&#x27;</span>:<span class="string">&#x27;4uj43w&#x27;</span>,<span class="string">&#x27;wxOpenId&#x27;</span>:<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;nickName&#x27;</span>:<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;headimgurl&#x27;</span>:<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;guid&#x27;</span>:<span class="string">&#x27;d8c3e2e1aee2be5b35e571711865189f&#x27;</span>,<span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;162498&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    r = requests.post(<span class="string">&#x27;https://res2.rrxiu.net/pluginPhotoVote/photoVoteData/vote&#x27;</span>,cookies=get_cookie.cookies,data=data)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷票</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>celery介绍</title>
    <url>/2018/05/10/celery%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Celery架构设计"><a href="#Celery架构设计" class="headerlink" title="Celery架构设计"></a>Celery架构设计</h2><p>Celery是一个用python编写的分布式的任务调度模块，它有着简明的 API，并且有丰富的扩展性，适合用于构建分布式的 Web 服务。celery的架构包括三个部分：消息中间件（message broker），任务执行单元（worker）和任务执行结果的存储（task result store）。</p>
<h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>celery本身不提供消息服务，但可以和第三方提供的消息中间件（<strong>RabbitMQ</strong>,<strong>Redis</strong>等）集成。</p>
<h4 id="任务执行单元"><a href="#任务执行单元" class="headerlink" title="任务执行单元"></a>任务执行单元</h4><p>worker是celery提供的任务执行单元，worker并发的运行在分布式的系统节点中。</p>
<h4 id="任务结果存储"><a href="#任务结果存储" class="headerlink" title="任务结果存储"></a>任务结果存储</h4><p>task result store用来存储worker执行的任务的结果，celery支持以不同方式存储任务的结果（<strong>AMQP</strong>,<strong>Redis</strong>,<strong>MongoDB</strong>）。</p>
<p>另外，celery还支持不同的并发（<strong>Prefork</strong>,<strong>Eventlet</strong>,<strong>gevent</strong>,<strong>threads</strong>）和序列化的手段（<strong>pickle</strong>,<strong>json</strong>,<strong>yaml</strong>等）。</p>
<h2 id="概图"><a href="#概图" class="headerlink" title="概图"></a>概图</h2><p><img src="http://obksgg9lx.bkt.clouddn.com/celery.png" alt="celery"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install celery</span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h4 id="消息中间件redis的配置-及任务结果存储"><a href="#消息中间件redis的配置-及任务结果存储" class="headerlink" title="消息中间件redis的配置,及任务结果存储"></a>消息中间件redis的配置,及任务结果存储</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CELERY_BROKER_URL = <span class="string">&#x27;redis://localhost:6379/0&#x27;</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://localhost:6379/0&#x27;</span></span><br><span class="line"><span class="comment"># 使用 update设置多个celery的参数</span></span><br><span class="line">celery.conf.update(app.config)</span><br></pre></td></tr></table></figure>

<h4 id="消费者task"><a href="#消费者task" class="headerlink" title="消费者task"></a>消费者task</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@celery.task(<span class="params">bind=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_task</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># 执行耗费资源的算法</span></span><br><span class="line">    algorithm.reset_data()</span><br><span class="line"></span><br><span class="line">    app = create_app(os.getenv(<span class="string">&#x27;FLASK_CONFIG&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> app.app_context():</span><br><span class="line">        front_data = algorithm.run_search(algorithm.TestData.requirement, algorithm.TestData.disabled_devices)</span><br><span class="line">        <span class="keyword">import</span> json</span><br><span class="line">        </span><br><span class="line">        data = json.dumps(front_data)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;current&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;total&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;Task completed!&#x27;</span>, <span class="string">&#x27;result&#x27;</span>: data&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过task-apply-async将任务压入消息队列broker中"><a href="#通过task-apply-async将任务压入消息队列broker中" class="headerlink" title="通过task.apply_async将任务压入消息队列broker中"></a>通过task.apply_async将任务压入消息队列broker中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@energy_island.route(<span class="params"><span class="string">&#x27;/get_graph_data&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_graph_data</span>():</span></span><br><span class="line">    <span class="built_in">id</span> = request.values.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    task = tasks.long_task.apply_async()</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;&#125;), <span class="number">202</span>, &#123;<span class="string">&#x27;Location&#x27;</span>: url_for(<span class="string">&#x27;energy_island.taskstatus&#x27;</span>, task_id=task.<span class="built_in">id</span>)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用backend异步获取结果task-AsyncResult"><a href="#使用backend异步获取结果task-AsyncResult" class="headerlink" title="使用backend异步获取结果task.AsyncResult"></a>使用backend异步获取结果task.AsyncResult</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@energy_island.route(<span class="params"><span class="string">&#x27;/status/&lt;task_id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskstatus</span>(<span class="params">task_id</span>):</span></span><br><span class="line">    task = tasks.long_task.AsyncResult(task_id)</span><br><span class="line">    <span class="keyword">if</span> task.state == <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">&#x27;state&#x27;</span>: task.state,</span><br><span class="line">            <span class="string">&#x27;current&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;Pending...&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">elif</span> task.state != <span class="string">&#x27;FAILURE&#x27;</span>:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">&#x27;state&#x27;</span>: task.state,</span><br><span class="line">            <span class="string">&#x27;current&#x27;</span>: task.info.get(<span class="string">&#x27;current&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: task.info.get(<span class="string">&#x27;total&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: task.info.get(<span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;result&#x27;</span> <span class="keyword">in</span> task.info:</span><br><span class="line">            response[<span class="string">&#x27;result&#x27;</span>] = task.info[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        response = &#123;</span><br><span class="line">            <span class="string">&#x27;state&#x27;</span>: task.state,</span><br><span class="line">            <span class="string">&#x27;current&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="built_in">str</span>(task.info),</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response)</span><br></pre></td></tr></table></figure>

<h4 id="生产者get消费者完成的状态"><a href="#生产者get消费者完成的状态" class="headerlink" title="生产者get消费者完成的状态"></a>生产者get消费者完成的状态</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> update_progress = <span class="function"><span class="keyword">function</span>(<span class="params">status_url</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send GET request to status URL</span></span><br><span class="line">    $.getJSON(status_url, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// update UI</span></span><br><span class="line">        percent = <span class="built_in">parseInt</span>(data[<span class="string">&#x27;current&#x27;</span>] * <span class="number">100</span> / data[<span class="string">&#x27;total&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="string">&#x27;state&#x27;</span>] != <span class="string">&#x27;PENDING&#x27;</span> &amp;&amp; data[<span class="string">&#x27;state&#x27;</span>] != <span class="string">&#x27;PROGRESS&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;result&#x27;</span> <span class="keyword">in</span> data) &#123;</span><br><span class="line"></span><br><span class="line">                setGraphDataRun(<span class="built_in">JSON</span>.parse(data[<span class="string">&#x27;result&#x27;</span>]), <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// show result</span></span><br><span class="line">                alert(<span class="string">&#x27;result-liubing: &#x27;</span> + data[<span class="string">&#x27;result&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">&#x27;state-liubing: &#x27;</span> + data[<span class="string">&#x27;state&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rerun in 2 seconds</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                update_progress(status_url);</span><br><span class="line">            &#125;, <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动celery"><a href="#启动celery" class="headerlink" title="启动celery"></a>启动celery</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">celery -A app.celery worker -l info -P eventlet</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>celery</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>为Jupyter Notebook添加目录</title>
    <url>/2018/04/24/%E4%B8%BAJupyter%20Notebook%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p> 为Jupyter Notebook生成目录，需要安装插件Jupyter notebook extensions：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda install -c conda-forge jupyter_contrib_nbextensions</span></span><br></pre></td></tr></table></figure>

<p>重启jupyter notebook，可以将代码中插入的markdown文字，采集成左侧目录。并可根据需求进行设置。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/notebook-extension.png" alt="notebook-extension"></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>jupyter notebook</tag>
        <tag>ai</tag>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title>利用AppVeyor做GithubIO的CI</title>
    <url>/2018/04/24/%E5%88%A9%E7%94%A8AppVeyor%E5%81%9AGithubIO%E7%9A%84CI/</url>
    <content><![CDATA[<h2 id="建立两个仓库"><a href="#建立两个仓库" class="headerlink" title="建立两个仓库"></a>建立两个仓库</h2><p>我基于hexo搭建的github.io，在更换电脑时无法随意的提交blog。（因每个机器都需要部署node+hexo的环境）<br>于是，我将我的github.io建立两个仓库。</p>
<ul>
<li>master仓库（hexo generate后生成的html等文件）</li>
<li>hexo仓库（原始文件，包含md文档及主题等）</li>
</ul>
<p>并将hexo仓库设置为这个repo的主仓库。</p>
<h2 id="AppVeyor"><a href="#AppVeyor" class="headerlink" title="AppVeyor"></a>AppVeyor</h2><p><a href="https://www.appveyor.com/">appveyor</a>是支持windows OS做CI的持续集成工具，可以使用GitHub账号登陆。绑定我的github.io项目。</p>
<h4 id="添加appveyor-yml到Source-Repo"><a href="#添加appveyor-yml到Source-Repo" class="headerlink" title="添加appveyor.yml到Source Repo"></a>添加appveyor.yml到Source Repo</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">clone_depth:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">access_token:</span></span><br><span class="line">    <span class="attr">secure:</span> [<span class="string">Your</span> <span class="string">Github</span> <span class="string">Access</span> <span class="string">Token</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ps:</span> <span class="string">Install-Product</span> <span class="string">node</span> <span class="number">6</span> <span class="comment">#因为我的hexo是3.71的版本，因此需要安装node 6</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node</span> <span class="string">--version</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">--version</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">artifacts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on_success:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">credential.helper</span> <span class="string">store</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ps:</span> <span class="string">Add-Content</span> <span class="string">&quot;$env:USERPROFILE\.git-credentials&quot;</span> <span class="string">&quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;%GIT_USER_EMAIL%&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;%GIT_USER_NAME%&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">--depth</span> <span class="number">5</span> <span class="string">-q</span> <span class="string">--branch=%TARGET_BRANCH%</span> <span class="string">%STATIC_SITE_REPO%</span> <span class="string">%TEMP%\static-site</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">%TEMP%\static-site</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">del</span> <span class="string">*</span> <span class="string">/f</span> <span class="string">/q</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">for</span> <span class="string">/d</span> <span class="string">%%p</span> <span class="string">IN</span> <span class="string">(*)</span> <span class="string">do</span> <span class="string">rmdir</span> <span class="string">&quot;%%p&quot;</span> <span class="string">/s</span> <span class="string">/q</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SETLOCAL</span> <span class="string">EnableDelayedExpansion</span> <span class="string">&amp;</span> <span class="string">robocopy</span> <span class="string">&quot;%APPVEYOR_BUILD_FOLDER%\public&quot;</span> <span class="string">&quot;%TEMP%\static-site&quot;</span> <span class="string">/e</span> <span class="string">&amp;</span> <span class="string">IF</span> <span class="type">!ERRORLEVEL</span><span class="string">!</span> <span class="string">EQU</span> <span class="number">1</span> <span class="string">(exit</span> <span class="number">0</span><span class="string">)</span> <span class="string">ELSE</span> <span class="string">(IF</span> <span class="type">!ERRORLEVEL</span><span class="string">!</span> <span class="string">EQU</span> <span class="number">3</span> <span class="string">(exit</span> <span class="number">0</span><span class="string">)</span> <span class="string">ELSE</span> <span class="string">(exit</span> <span class="number">1</span><span class="string">))</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">-A</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Update Static Site&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">%TARGET_BRANCH%</span> <span class="string">&amp;&amp;</span> <span class="string">appveyor</span> <span class="string">AddMessage</span> <span class="string">&quot;Static Site Updated&quot;</span></span><br></pre></td></tr></table></figure>
<p>在GitHub生成好Access Token之后，你需要到<a href="https://ci.appveyor.com/tools/encrypt">AppVeyor加密页面</a>把Access Token加密之后再替换[Your GitHub Access Token]。<br><img src="http://obksgg9lx.bkt.clouddn.com/github-access-token.png" alt="github-access-token"><br><img src="http://obksgg9lx.bkt.clouddn.com/github-webhook.png" alt="github-webhook"></p>
<h4 id="设置Appveyor的settings"><a href="#设置Appveyor的settings" class="headerlink" title="设置Appveyor的settings"></a>设置Appveyor的settings</h4><p><img src="http://obksgg9lx.bkt.clouddn.com/appveyor-setting1-.jpg" alt="appveyor-setting1"><br>在Appveyor Settings的Environment里设置以下四个变量。STATIC_SITE_REPO就是github Repo的地址，TARGET_BRANCH是Repo的目标branch（这里是master，相当于提交编译后的html等文件至master），GIT_USER_EMAIL和GIT_USER_NAME就是你GitHub账号的信息。<br><img src="http://obksgg9lx.bkt.clouddn.com/appveyor-setting2-.jpg" alt="appveyor-setting2"><br>在Appveyor Settings的build里默认是MSBUILD，因为是appveyor.yml中配置的脚本来build的，因此这里改成SCRIPT。<br><img src="http://obksgg9lx.bkt.clouddn.com/appveyor-setting3.png" alt="appveyor-setting3"></p>
<h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>本地在hexo的分支下写md文档，提交至github上，触发AppVeyor的webhook，AppVeyor会git clone下hexo的最新代码，并且build成目标文件，将目标文件push至master分支。则完成了整体刷新页面，持续部署的工作了。<br>可以在线监控build的状况：<br><img src="http://obksgg9lx.bkt.clouddn.com/appveyor-build-log.png" alt="appveyor-build-log"></p>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>CI</tag>
        <tag>hexo</tag>
        <tag>持续部署</tag>
        <tag>AppVeyor</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>git删除所有提交历史记录</title>
    <url>/2018/04/20/git%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --orphan latest_branch</span><br></pre></td></tr></table></figure>

<h2 id="添加所有文件"><a href="#添加所有文件" class="headerlink" title="添加所有文件"></a>添加所有文件</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<p>   ​</p>
<h2 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;something about message&quot;</span><br></pre></td></tr></table></figure>
<p>   ​</p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -D master</span><br></pre></td></tr></table></figure>
<p>   ​</p>
<h2 id="重命名当前branch为目标名"><a href="#重命名当前branch为目标名" class="headerlink" title="重命名当前branch为目标名"></a>重命名当前branch为目标名</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m master</span><br></pre></td></tr></table></figure>

<p>   ​</p>
<h2 id="强制push"><a href="#强制push" class="headerlink" title="强制push"></a>强制push</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>
<p>   ​</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装postgresql</title>
    <url>/2017/12/07/centos7%E5%AE%89%E8%A3%85postgresql/</url>
    <content><![CDATA[<h2 id="安装启动postgresql"><a href="#安装启动postgresql" class="headerlink" title="安装启动postgresql"></a>安装启动postgresql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install postgresql-server</span><br><span class="line">service postgresql initdb</span><br><span class="line">service postgresql start</span><br></pre></td></tr></table></figure>
<h2 id="修改管理员密码"><a href="#修改管理员密码" class="headerlink" title="修改管理员密码"></a>修改管理员密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - postgres</span><br><span class="line">psql</span><br><span class="line"><span class="meta">$</span><span class="bash"> ALTER USER postgres WITH PASSWORD <span class="string">&#x27;postgres&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h2><p>修改**/var/lib/pgsql/data/postgresql.conf**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<p>修改客户端认证配置文件**/var/lib/pgsql/data/pg_hba.conf**,添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host  all  all   10.0.0.0/8  md5</span><br></pre></td></tr></table></figure>

<h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service postgresql restart</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>centos7</tag>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>配置gitbucket的webhook触发jenkins自动构建</title>
    <url>/2017/11/20/%E9%85%8D%E7%BD%AEgitbucket%E7%9A%84webhook%E8%A7%A6%E5%8F%91jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="jenkins安装gitbucket插件"><a href="#jenkins安装gitbucket插件" class="headerlink" title="jenkins安装gitbucket插件"></a>jenkins安装gitbucket插件</h2><p>在jenkins中安装插件:<strong>Gitbucket Plugin</strong><br>安装好了之后配置构建触发器。<br><img src="http://obksgg9lx.bkt.clouddn.com/triggle.png" alt="构建触发器"></p>
<h2 id="gitbucket设置webhook"><a href="#gitbucket设置webhook" class="headerlink" title="gitbucket设置webhook"></a>gitbucket设置webhook</h2><p>使用root管理员账户进入需要设置webhook的具体项目中Settings-&gt;Service Hooks菜单下，配置gitbucket的webhook。<br><img src="http://obksgg9lx.bkt.clouddn.com/gitbucket.png" alt="配置webhook"></p>
<h2 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h2><p>source提交git。<br><img src="http://obksgg9lx.bkt.clouddn.com/push-status.png" alt="push状态"></p>
<p>自动触发构建。<br><img src="http://obksgg9lx.bkt.clouddn.com/console.png" alt="自动构建"></p>
]]></content>
      <tags>
        <tag>jenkins</tag>
        <tag>持续部署</tag>
        <tag>gitbucket</tag>
        <tag>webhook</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins自动部署docker应用</title>
    <url>/2017/11/17/jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2docker%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>目前需要部署一个基于python flask的web服务，数据库使用的是postgresql。</p>
<h2 id="思路-amp-流程"><a href="#思路-amp-流程" class="headerlink" title="思路&amp;流程"></a>思路&amp;流程</h2><ul>
<li>准备docker镜像</li>
<li>jenkins拉取远端源码–git</li>
<li>实现应用打包–jenkins本地</li>
<li>把应用打包进docker镜像–dockerfile</li>
<li>镜像同步到docker私有仓库–shell docker命令</li>
<li>删除老的docker容器–shell docker命令</li>
<li>运行新的docker容器–shell docker命令</li>
</ul>
<h3 id="准备docker镜像"><a href="#准备docker镜像" class="headerlink" title="准备docker镜像"></a>准备docker镜像</h3><h4 id="创建自定义flask镜像"><a href="#创建自定义flask镜像" class="headerlink" title="创建自定义flask镜像"></a>创建自定义flask镜像</h4><p>基于<strong>tiangolo/uwsgi-nginx-flask</strong>创建flask的镜像。<br>自定义flask镜像的dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM tiangolo/uwsgi-nginx-flask:python2.7</span><br><span class="line"></span><br><span class="line">COPY ./app /app</span><br><span class="line">COPY ./lib/libseuif97.so /usr/lib</span><br><span class="line">RUN pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>因为网络环境不好，安装requirements.txt中python的第三方库时，发生报错，因此我将基本的库事先安装好。<br>并且把需要的so静态文件也COPY进镜像中。<br>后面如果有变化，可以根据需要在jenkins中再动态生成dockerfile并执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t test-flask .</span><br></pre></td></tr></table></figure>

<h4 id="创建自定义的postgresql"><a href="#创建自定义的postgresql" class="headerlink" title="创建自定义的postgresql"></a>创建自定义的postgresql</h4><p>自定义postgresql镜像的dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM postgres:9.3</span><br><span class="line"></span><br><span class="line">ADD ./sql /docker-entrypoint-initdb.d/</span><br></pre></td></tr></table></figure>
<p>我们有一些master表，以及基础数据，我们需要在运行这个容器之前，将这些基础数据insert进db这个docker之中。<br>可以把各种sql文件放入/sql路径下。</p>
<h4 id="commit到私有docker仓库"><a href="#commit到私有docker仓库" class="headerlink" title="commit到私有docker仓库"></a>commit到私有docker仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -m &quot;flask插件安装&quot; -a &quot;liubing&quot; $containId liubing/test-flask</span><br><span class="line">docker tag liubing/$imageName $dockerRegistsryAddress/test-flask</span><br><span class="line">docker push $dockerRegistsryAddress/test-flask</span><br></pre></td></tr></table></figure>

<p>db的docker也可提前commit到私有仓库。</p>
<h3 id="jenkins拉源码"><a href="#jenkins拉源码" class="headerlink" title="jenkins拉源码"></a>jenkins拉源码</h3><p>在jenkins中配置“源码管理”，输入source仓库的git地址，并绑定git用户及需要检测状态变化的branch。在构建时会自动下载git源码的。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/git.png" alt="配置git地址"></p>
<h3 id="实现应用打包"><a href="#实现应用打包" class="headerlink" title="实现应用打包"></a>实现应用打包</h3><p>目前开发的是一个python项目，python不需要打包。源码即可执行。</p>
<h3 id="把应用打包进docker镜像"><a href="#把应用打包进docker镜像" class="headerlink" title="把应用打包进docker镜像"></a>把应用打包进docker镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;From $dockerRegistsryAddress/test-flask</span><br><span class="line">MAINTAINER liubing &quot;lbingg@hotmail.com&quot;</span><br><span class="line"></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line">&#x27; &gt; Dockerfile;</span><br></pre></td></tr></table></figure>
<p>jenkins中执行的脚本会默认当前脚本处于jenkins环境中的workspace中的当前应用工程下。因此在copy程序时，我们需要将当前目录下的所有文件全部拷贝入新创建docker镜像的/app目录中。</p>
<h3 id="镜像同步到docker私有仓库"><a href="#镜像同步到docker私有仓库" class="headerlink" title="镜像同步到docker私有仓库"></a>镜像同步到docker私有仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t $dockerRegistsryAddress/test-flask;</span><br></pre></td></tr></table></figure>
<h3 id="删除老的docker容器"><a href="#删除老的docker容器" class="headerlink" title="删除老的docker容器"></a>删除老的docker容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop postgresql || true;</span><br><span class="line">docker rm postgresql || true;</span><br><span class="line">docker stop test-flask || true;</span><br><span class="line">docker rm test-flask || true;</span><br></pre></td></tr></table></figure>

<h3 id="运行新的docker容器"><a href="#运行新的docker容器" class="headerlink" title="运行新的docker容器"></a>运行新的docker容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name=postgresql -itd --restart always --publish 5432:5432 --volume /opt/postgresql/data:/var/lib/postgresql --env &#x27;DB_USER=postgres&#x27; --env &#x27;DB_PASS=postgres&#x27; --env &#x27;DB_NAME=postgres&#x27; $dockerRegistryAddress:5000/test-db-1;</span><br><span class="line"></span><br><span class="line">docker run --name test-flask --publish 80:80 --link postgresql:postgres -d $dockerRegistryAddress:5000/test-flask;</span><br></pre></td></tr></table></figure>

<p>jenkins中的“构建”配置</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/structure.png" alt="配置构建"></p>
<h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>需要在jenkins的docker中运行其他的docker命令，可以使用Docker outside of Docker来配置。<br><img src="http://liubing1545.github.io/2017/11/16/Docker-outside-of-Docker" alt="Docker-outside-of-Docker"></p>
]]></content>
      <tags>
        <tag>jenkins</tag>
        <tag>docker</tag>
        <tag>持续部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker outside of Docker</title>
    <url>/2017/11/16/Docker-outside-of-Docker/</url>
    <content><![CDATA[<h2 id="添加用户jenkins至docker组"><a href="#添加用户jenkins至docker组" class="headerlink" title="添加用户jenkins至docker组"></a>添加用户jenkins至docker组</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果不存在docker组就groupadd一个</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo groupadd docker</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户jenkins至docker组</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gpasswd -a jenkins docker</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service docker restart</span></span><br></pre></td></tr></table></figure>


<h2 id="自定义jenkins镜像"><a href="#自定义jenkins镜像" class="headerlink" title="自定义jenkins镜像"></a>自定义jenkins镜像</h2><p>镜像Dockerfile    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">From jenkins</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line">AGR dockerGid=995</span><br><span class="line"></span><br><span class="line">RUN echo &quot;docker:x:$&#123;dockerGid&#125;:jenkins&quot; &gt;&gt; /etc/group</span><br><span class="line"></span><br><span class="line">USER jenkins</span><br></pre></td></tr></table></figure>

<p>其中的dockerGid是docker组id，可以在宿主机里<strong>cat /etc/group | grep ^docker</strong>查看组id序号。    </p>
<h3 id="docker-dial-unix-var-run-docker-sock-permission-denied"><a href="#docker-dial-unix-var-run-docker-sock-permission-denied" class="headerlink" title="docker:dial unix /var/run/docker.sock:permission denied."></a>docker:dial unix /var/run/docker.sock:permission denied.</h3><p>上面的dockerfile内容关键是将宿主机的docker组及用户配置，写入docker镜像里，防止在docker容器里运行docker命令没有权限，会报错。<br><strong>一定要注意，设置的dockerGid一定要与宿主机的组id一致。</strong></p>
<h3 id="build自定义镜像"><a href="#build自定义镜像" class="headerlink" title="build自定义镜像"></a>build自定义镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t local_jenkins</span><br></pre></td></tr></table></figure>

<h2 id="Docker进程监听的Unix域socket"><a href="#Docker进程监听的Unix域socket" class="headerlink" title="Docker进程监听的Unix域socket"></a>Docker进程监听的Unix域socket</h2><h3 id="var-run-docker-sock"><a href="#var-run-docker-sock" class="headerlink" title="/var/run/docker.sock"></a>/var/run/docker.sock</h3><p>这个文件是什么呢？简单地说，它是Docker守护进程(Docker daemon)默认监听的Unix域套接字(Unix domain socket)，容器中的进程可以通过它与Docker守护进程进行通信。</p>
<h3 id="管理jenkins的docker-compose"><a href="#管理jenkins的docker-compose" class="headerlink" title="管理jenkins的docker-compose"></a>管理jenkins的docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  my_jenkins:</span><br><span class="line">    image: local_jenkins</span><br><span class="line">    volumes:</span><br><span class="line">      - ./jenkins_home:/var/jenkins_home</span><br><span class="line">      - /bin/docker:/usr/bin/docker</span><br><span class="line">      - /usr/bin/docker.sock:/var/run/docker.sock</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8081:8080&quot;</span><br></pre></td></tr></table></figure>
<p>在这个docker-compose中，我们挂载了**/bin/docker**,<strong>/var/run/docker.sock</strong>，实现了DooD(Docker outside of Docker)。在jenkins镜像里run起来的容器实际上就是运行在宿主机上的。</p>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>CI</tag>
        <tag>DooD</tag>
        <tag>jenkins</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于android资源文件路径</title>
    <url>/2017/11/04/%E5%85%B3%E4%BA%8Eandroid%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="android资源文件的目录："><a href="#android资源文件的目录：" class="headerlink" title="android资源文件的目录："></a>android资源文件的目录：</h2><ul>
<li>res/raw文件夹</li>
<li>asserts文件夹</li>
</ul>
<h4 id="res-raw"><a href="#res-raw" class="headerlink" title="res/raw"></a>res/raw</h4><p>不能创建文件夹，只可创建文件。</p>
<h4 id="asserts"><a href="#asserts" class="headerlink" title="asserts"></a>asserts</h4><ul>
<li>可以创建文件夹。</li>
<li>AssertManager没有提供直接获取asserts文件夹folder路径的function。 </li>
</ul>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>上传IOS APP一直卡在&#39;Authenticating with the iTunes store&#39;</title>
    <url>/2017/09/29/%E4%B8%8A%E4%BC%A0IOS-APP%E4%B8%80%E7%9B%B4%E5%8D%A1%E5%9C%A8-Authenticating-with-the-iTunes-store/</url>
    <content><![CDATA[<h3 id="打开终端："><a href="#打开终端：" class="headerlink" title="打开终端："></a>打开终端：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mv .itmstransporter/ .old_itmstransporter/</span><br><span class="line">&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter&quot;</span><br></pre></td></tr></table></figure>
<p>当Transporter更新完成之后，再上传ios app就好了。<br><a href="https://stackoverflow.com/questions/22443425/application-loader-stuck-at-authenticating-with-the-itunes-store-when-uploadin/40423739#40423739">参考stackoverflow</a></p>
]]></content>
      <tags>
        <tag>app</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>anaconda安装tensorflow</title>
    <url>/2017/08/29/anaconda%E5%AE%89%E8%A3%85tensorflow/</url>
    <content><![CDATA[<h2 id="下载anaconda"><a href="#下载anaconda" class="headerlink" title="下载anaconda"></a>下载anaconda</h2><p>anaconda是一个用于科学计算的python发行版，支持linux、mac、windows系统。<br><a href="https://www.continuum.io/downloads">anaconda官方下载地址</a><br>我下载的版本是python27的anaconda2-4.4.0-Windows-x86_64.exe    </p>
<h2 id="创建python3的anaconda环境"><a href="#创建python3的anaconda环境" class="headerlink" title="创建python3的anaconda环境"></a>创建python3的anaconda环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n python3 python=3.5.2 anaconda</span><br></pre></td></tr></table></figure>

<h2 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前版本分支</span></span><br><span class="line">conda info -e</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换python3的环境</span></span><br><span class="line">activate python3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装tensorflow</span></span><br><span class="line">conda install tensorflow</span><br></pre></td></tr></table></figure>

<h2 id="启动spyder"><a href="#启动spyder" class="headerlink" title="启动spyder"></a>启动spyder</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在python3的虚拟环境下</span></span><br><span class="line">spyder</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>anaconda</tag>
        <tag>conda</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose的使用</title>
    <url>/2017/07/27/docker-compose%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>docker compose是一个用来定义和运行复杂应用的docker工具。使用compose，你可以在一个文件中定义一个多容器应用，然后使用一条命令来启动应用。    </p>
<h2 id="下载docker-compose"><a href="#下载docker-compose" class="headerlink" title="下载docker-compose"></a>下载docker-compose</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.3.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="创建应用目录"><a href="#创建应用目录" class="headerlink" title="创建应用目录"></a>创建应用目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir compose-gitbucket</span><br><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose-yml配置文件"><a href="#docker-compose-yml配置文件" class="headerlink" title="docker-compose.yml配置文件"></a>docker-compose.yml配置文件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitbucket:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">f99aq8ove/gitbucket</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./gitbucket:/gitbucket</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;29418:29418&quot;</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><blockquote>
<p>build 构建或重建服务<br>help 命令帮助<br>kill 杀掉容器<br>logs 显示容器的输出内容<br>port 打印绑定的开放端口<br>ps 显示容器<br>pull 拉取服务镜像<br>restart 重启服务<br>rm 删除停止的容器<br>run 运行一个一次性命令<br>scale 设置服务的容器数目<br>start 开启服务<br>stop 停止服务<br>up 创建并启动容器    </p>
</blockquote>
<p>一般up之后，又改写了yml配置文件，则需要rm掉旧的容器，再up。</p>
<h2 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h2><p>在应用目录下启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>docker设置http代理</title>
    <url>/2017/07/24/docker%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>

<h4 id="创建http-proxy-conf文件"><a href="#创建http-proxy-conf文件" class="headerlink" title="创建http-proxy.conf文件"></a>创建http-proxy.conf文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>

<h4 id="在http-proxy-conf文件中记入"><a href="#在http-proxy-conf文件中记入" class="headerlink" title="在http-proxy.conf文件中记入"></a>在http-proxy.conf文件中记入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://username:passwd@hostname:port/&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="reload配置及重启docker服务"><a href="#reload配置及重启docker服务" class="headerlink" title="reload配置及重启docker服务"></a>reload配置及重启docker服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl show docker --property Environment</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>docker创建私有仓库</title>
    <url>/2017/07/24/docker%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="拉取registry的镜像"><a href="#拉取registry的镜像" class="headerlink" title="拉取registry的镜像"></a>拉取registry的镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull registry:2.1.1</span><br></pre></td></tr></table></figure>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -v /root/compose-docker-registry:/var/lib/registry -p 5000:5000 --restart=always --name registry2 --privileged registry:2.1.1</span><br></pre></td></tr></table></figure>
<h2 id="打包镜像push到本地仓库"><a href="#打包镜像push到本地仓库" class="headerlink" title="打包镜像push到本地仓库"></a>打包镜像push到本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag postgres $registry-address:5000/postgres</span><br><span class="line">docker push $registry-address:5000/postgres</span><br></pre></td></tr></table></figure>
<h2 id="list仓库中的镜像"><a href="#list仓库中的镜像" class="headerlink" title="list仓库中的镜像"></a>list仓库中的镜像</h2><p>在client端执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XGET http://$registry-address:5000/v2/_catalog    </span><br></pre></td></tr></table></figure>

<h2 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h2><h4 id="docker-received-unexpected-HTTP-status-501-Not-Implemented"><a href="#docker-received-unexpected-HTTP-status-501-Not-Implemented" class="headerlink" title="docker received unexpected HTTP status:501 Not Implemented"></a>docker received unexpected HTTP status:501 Not Implemented</h4><p>这个问题是client端配置了docker的http-proxy，没有将docker的私有仓库registry所在ip设为例外导致的。</p>
<h4 id="server-gave-HTTP-response-to-HTTPS-client"><a href="#server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="server gave HTTP response to HTTPS client"></a>server gave HTTP response to HTTPS client</h4><p>registry默认的是https协议，因此需要在client端配置insecure-registries。<br>我的docker版本是1.12.1，配置文件是/etc/docker/daemon.json    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;$registry-address:5000&quot;]&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title>win10启动vagrant</title>
    <url>/2017/07/18/win10%E5%90%AF%E5%8A%A8vagrant/</url>
    <content><![CDATA[<p>win10环境下vagrant启动会报错。    </p>
<h2 id="正常启动步骤："><a href="#正常启动步骤：" class="headerlink" title="正常启动步骤："></a>正常启动步骤：</h2><h3 id="设置virtual-box的adapter网卡"><a href="#设置virtual-box的adapter网卡" class="headerlink" title="设置virtual box的adapter网卡"></a>设置virtual box的adapter网卡</h3><p>打开Preferences -&gt; Network -&gt; Host-only Networks Tab    </p>
<ul>
<li>将默认的adapter网卡的ipv4的地址，改写成192.168.xx.1</li>
<li>将mask改为255.255.255.0</li>
</ul>
<h3 id="启动vagrant"><a href="#启动vagrant" class="headerlink" title="启动vagrant"></a>启动vagrant</h3><pre><code>$ vagrant up 
</code></pre>
<p>如果启动时报错    </p>
<pre><code>Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
There was an error while executing `VBoxManage`, a CLI used by Vagrant
for controlling VirtualBox. The command and stderr is shown below.

Command: [&quot;hostonlyif&quot;, &quot;create&quot;]

Stderr: 0%...
Progress state: E_FAIL
VBoxManage.exe: error: Failed to create the host-only adapter
VBoxManage.exe: error: Code E_FAIL (0x80004005) - Unspecified error (extended info not available)
VBoxManage.exe: error: Context: &quot;int __cdecl handleCreate(struct HandlerArg ,int,int )&quot; at line 68 of file VBoxManageHostonly.cpp
</code></pre>
<ol>
<li>check下virtual box有没有创建一个新的adapter网卡。</li>
<li>check该网卡的ipv4的地址是以192.168开头的。</li>
<li>如果成功创建了，则再次vagrant up。就启动成功了。</li>
</ol>
]]></content>
      <tags>
        <tag>vagrant</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>web.py与gunicorn</title>
    <url>/2017/07/07/web.py%E4%B8%8Egunicorn/</url>
    <content><![CDATA[<p>web.py的application.py模块，主要实现了WSGI兼容的接口，以便应用程序被WSGI应用服务器调用。   </p>
<h2 id="WSGI接口的实现"><a href="#WSGI接口的实现" class="headerlink" title="WSGI接口的实现"></a>WSGI接口的实现</h2><pre><code>app = web.application(urls, globals())
application = app.wsgifunc()
</code></pre>
<h2 id="Gunicorn-conf的配置"><a href="#Gunicorn-conf的配置" class="headerlink" title="Gunicorn.conf的配置"></a>Gunicorn.conf的配置</h2><pre><code>workers = 3
bind = &#39;127.0.0.1:8000&#39;
</code></pre>
<h2 id="Gunicorn的启动方式"><a href="#Gunicorn的启动方式" class="headerlink" title="Gunicorn的启动方式"></a>Gunicorn的启动方式</h2><pre><code>/$path/bin/gunicorn $filename:application -c /$path/gunicorn.conf
</code></pre>
]]></content>
      <tags>
        <tag>web.py</tag>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title>supervisor管理服务器进程</title>
    <url>/2017/07/07/supervisor%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>在服务器上同时管理多个java进程和python进程，我使用supervisor。<br>在/etc/supervisor/conf.d/路径下创建xxx.conf<br>在xxx.conf下配置如下    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:gzh]</span><br><span class="line">command=/root/python-gzh/venv/bin/gunicorn main:application -c /root/python-gzh/gunicorn.conf</span><br><span class="line">directory=/root/python-gzh</span><br><span class="line">user=root</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stdout_logfile=/root/python-gzh/logs/gzh.log</span><br><span class="line"></span><br><span class="line">[program:provider]</span><br><span class="line">command=java -jar /root/springboot/platform-system-provider.jar --spring.profiles.active=prod</span><br><span class="line">directory=/root/springboot</span><br><span class="line">user=root</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stdout_logfile=/root/springboot/logs/provider.log</span><br><span class="line"></span><br><span class="line">[program:webapi]</span><br><span class="line">command=java -jar /root/springboot/platform-mobile-client.jar --spring.profiles.active=prod</span><br><span class="line">directory=/root/springboot</span><br><span class="line">user=root</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stdout_logfile=/root/springboot/logs/webapi.log</span><br><span class="line"></span><br><span class="line">[program:web]</span><br><span class="line">command=java -jar /root/springboot/platform-admin-web.jar --spring.profiles.active=prod</span><br><span class="line">directory=/root/springboot</span><br><span class="line">user=root</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stdout_logfile=/root/springboot/logs/web.log</span><br></pre></td></tr></table></figure>
<p>通过supervisorctl可以监控管理各种进程的状态了。</p>
]]></content>
      <tags>
        <tag>supervisor</tag>
        <tag>sprintboot</tag>
        <tag>web.py</tag>
      </tags>
  </entry>
  <entry>
    <title>Write failed: Broken pipe</title>
    <url>/2017/07/05/Write-failed-Broken-pipe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Write-failed-Broken-pipe"><a href="#Write-failed-Broken-pipe" class="headerlink" title="Write failed: Broken pipe"></a>Write failed: Broken pipe</h3><p>ssh远程连接阿里云centos服务器时，隔几分钟不操作，就会报错：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write failed: Broken pipe   </span><br></pre></td></tr></table></figure>

<p>解决方法：<br>在/etc/ssh/sshd_config文件中，添加如下配置：　    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval 60   </span><br></pre></td></tr></table></figure>
<p>重启一下就生效了。</p>
]]></content>
      <tags>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器启动iptables报错</title>
    <url>/2017/03/28/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8iptables%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker0: iptables: No chain/target/match by that name</span><br></pre></td></tr></table></figure>
<h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<h3 id="列出iptables的所有规则"><a href="#列出iptables的所有规则" class="headerlink" title="列出iptables的所有规则"></a>列出iptables的所有规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure>
<p>可以看到iptables里面多出了Chain Docker的选项。<br>经验为：在启动firewalld之后，iptables被激活，此时没有docker chain，重启docker后被加入到iptable里面。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>java工程启动 No Route to host</title>
    <url>/2017/03/28/java%E5%B7%A5%E7%A8%8B%E5%90%AF%E5%8A%A8No-Route-to-host/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>检查宿主机防火墙是否开启    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state #查看默认防火墙状态（关闭后显示not running，开启后显示running）    </span><br><span class="line">systemctl stop firewalld.service #停止firewall    </span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动    </span><br></pre></td></tr></table></figure></li>
<li>确认project工程连接的postgresql服务是映射到宿主机的ip及port，而不是postgresql docker自身的ip及port</li>
<li>确认postgresql服务docker的pg_hba.conf文件，是否设置接收任意的ip发来的请求<br>pg_hba.conf:    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host    all             all             0.0.0.0/0               md5    </span><br></pre></td></tr></table></figure></li>
<li>确认postgresql服务docker的postgres.conf文件的监听端口<br>postgres.conf:    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen_addresses = &#x27;*&#x27;      # what IP address(es) to listen on;    </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>netstat -tunlp命令</strong>查看下监听状态是否正常    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active Internet connections (only servers)                                 </span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:5432            0.0.0.0:*               LISTEN      816/postgres         </span><br><span class="line">tcp6       0      0 :::5432                 :::*                    LISTEN      816/postgres</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://stackoverflow.com/questions/25069832/docker-tomcat-and-postgresql-containers-in-same-host-no-route-to-host">stackoverflow解决方法</a></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>java</tag>
        <tag>No Route to host</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署web环境</title>
    <url>/2017/03/28/docker%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. docker pull sameersbn/postgresql</span><br><span class="line">2. docker run --name=postgresql -itd --restart always \</span><br><span class="line">--publish 5432:5432 \</span><br><span class="line">--volume /opt/postgresql/data:/var/lib/postgresql \</span><br><span class="line">--env &#x27;DB_USER=mymebyo_adm01&#x27; --env &#x27;DB_PASS=mymebyo_adm01&#x27; --env &#x27;DB_NAME=mymebyo&#x27; \</span><br><span class="line">sameersbn/postgresql    </span><br></pre></td></tr></table></figure>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. docker pull redis</span><br><span class="line">2. docker run --name=redis -p 6379:6379 -v /opt/redis/data:/data -d redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure>
<p><strong>redis-server –appendonly yes</strong> :在容器执行redis-server启动命令，并打开redis持久化配置</p>
<h3 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a>java web</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. docker pull java</span><br><span class="line">2. docker run -it --volume /var/www:/var/www --publish 8082:8080 --link postgresql:mebyo --link redis:redis java /bin/bash</span><br><span class="line">3. java -jar mebyo-1.0.0.jar</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
        <tag>postgresql</tag>
        <tag>redis</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1</title>
    <url>/2017/03/28/YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-at-line-4-column-1/</url>
    <content><![CDATA[<p>在hexo generate时，报错:</p>
<pre><code>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1
</code></pre>
<p>原因是在tags:hexo之间hexo之前要加一个空格！！！</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机磁盘扩容</title>
    <url>/2017/03/28/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>安装了centos7的虚拟机，yum update时报错空间不足 <strong>No space left on device</strong>。</p>
<h3 id="VBoxManage-modifyhd"><a href="#VBoxManage-modifyhd" class="headerlink" title="VBoxManage modifyhd"></a>VBoxManage modifyhd</h3><p>在宿主机上的安装virtualBox的根目录执行resize命令进行扩容:    </p>
<pre><code>C:\Program Files\Oracle\VirtualBox&gt;VBoxManage modifyhd E:\dockerVM\dockerVM.vdi --resize 35000
</code></pre>
<h3 id="CentOS的LVM管理"><a href="#CentOS的LVM管理" class="headerlink" title="CentOS的LVM管理"></a>CentOS的LVM管理</h3><p>查看磁盘状况</p>
<pre><code>$ fdisk -l /dev/sda
</code></pre>
<p>将空余磁盘创建为SDA3</p>
<pre><code>$ fdisk /dev/sda
n &#123;new partition&#125;
p &#123;primary partition&#125;
3 &#123;partition number&#125;

t &#123;change partition id&#125;
3 &#123;partition number&#125;
8e &#123;linux LVM partition&#125;
w
</code></pre>
<p>重启虚拟机</p>
<pre><code>$reboot
</code></pre>
<p>查看当前Volume group</p>
<pre><code>$ vgdisplay
</code></pre>
<p>创建/dev/sda3，根据VG Name:[centos]，扩展LVM的逻辑卷</p>
<pre><code>$ lvscan
$ pvcreate /dev/sda3
$ vgextend /dev/centos/root /dev/sda3
</code></pre>
<p>调整逻辑卷文件系统的大小</p>
<pre><code>$ xfs_growfs /dev/centos/root
$df -h
</code></pre>
<p>OK了！</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>磁盘扩容</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建gitbucket的docker环境</title>
    <url>/2016/12/27/%E6%90%AD%E5%BB%BAgitbucket%E7%9A%84docker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>为了更方便简洁的部署各种服务器应用，我在社内环境安装了docker。<br>从社内直连github有时极不稳定。社内团队协同开发，搭建本地的git仓库，我选择搭建gitbucket。  </p>
<pre><code>$ docker search gitbucket
</code></pre>
<p>虽然没有docker官方放出的gitbucket镜像，但从列表里选stars最多也算靠谱点儿吧。  </p>
<pre><code>$ docker pull f99aq8ove/gitbucket
</code></pre>
<p>github也不网络稳定啊。。。下载两次都失败，寻找国内的镜像找到了daocloud。去daocloud官网去注册一下，然后配置docker加速器。  </p>
<pre><code>$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://5706b345.m.daocloud.io
</code></pre>
<p>该脚本可以将 –registry-mirror 加入到你的docker配置文件 /etc/default/docker 中。</p>
<p>配置好了之后，再次docker pull。成功！<br>启动镜像。  </p>
<pre><code>$ docker run -d -p 8080:8080 -p 29418:29418 -v $&#123;PWD&#125;/gitbucket-data:/gitbucket f99aq8ove/gitbucket
</code></pre>
<p>配置了映射端口8080是gitbucket的网页入口，映射端口29418是ssh的端口。<br>正常启动后，通过网页打开，显示正常。<br>创建用户组，创建新的repository。<br>在客户端local创建开发环境。  </p>
<pre><code>$ mkdir xxxdir
$ cd xxxdir
$ touch README.md
$ git add .
$ git commit -m &quot;first commit&quot;
$ git remote add origin [URL]
$ git push origin master
</code></pre>
<p>在进行push的时候，失败了，报错如下。  </p>
<pre><code>fatal: unable to access &#39;http://xxx.git/&#39;: The requested URL returned error: 503
</code></pre>
<p>查了一下，有可能是在gitbucket服务器之前，设置了http代理所导致的。设置git http操作的debug。  </p>
<pre><code>$ export GIT_CURL_VERBOSE = 1
</code></pre>
<p>再次git push查看，的确有从http代理向gitbucket服务器发出的请求。但我不知道在哪里配置了http代理了。。。<br>使用git config命令查看配置文件  </p>
<p>查看仓库级的config  </p>
<pre><code>$ git config -local -l
</code></pre>
<p>查看全局级的config</p>
<pre><code>$ git config -global -l
</code></pre>
<p>查看系统级的config</p>
<pre><code>$ git config -system -l
</code></pre>
<p>查看当前生效的配置</p>
<pre><code>$ git config -l
</code></pre>
<p>ok！将设置的http代理全部注释掉，git push成功啦！<br>社内gitbucket搭建成功！</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>git</tag>
        <tag>gitbucket</tag>
      </tags>
  </entry>
  <entry>
    <title>git删除tag</title>
    <url>/2016/11/23/git%E5%88%A0%E9%99%A4tag/</url>
    <content><![CDATA[<p>同事在git上误打了tag，并且只删除了本地的tag，没有删除origin上的tag。管理员账户登录了git仓库的web页面，找到了这个tag但还是没有办法删掉。<br>ok！只有命令行开搞！  </p>
<h4 id="配置ssh-config"><a href="#配置ssh-config" class="headerlink" title="配置ssh config"></a>配置ssh config</h4><p><img src="http://obksgg9lx.bkt.clouddn.com/ssh-config.png" alt="webapi"></p>
<h4 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h4><p><img src="http://obksgg9lx.bkt.clouddn.com/delete-tag.png" alt="webapi"></p>
<h4 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h4><pre><code>ssh-agent
eval `ssh-agent`
ssh-add $git_rsa
git tag -d $tag_name
git push origin :refs/tags/tag_name
</code></pre>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git撤销merge操作</title>
    <url>/2016/09/18/git%E6%92%A4%E9%94%80merge%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>使用git偶尔会遇到merge错代码的情形，这时需要撤销merge的操作。    </p>
<pre><code>$ git show bb46d15
</code></pre>
<p>commit id 是 bb46d15。<br>可以看到merge commit的parents次序。该次序从1开始，想保留哪个parent就指定它的序号。</p>
<pre><code>$ git revert -m 2 bb46d15
</code></pre>
<p>2是想要保留的parent branch序号，其他的parent branch会撤销掉。<br>bb46d15是指定对具体的commit id进行操作。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>开发团队跨平台开发环境集中管理化之vagrant</title>
    <url>/2016/08/12/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E5%8C%96%E4%B9%8Bvagrant/</url>
    <content><![CDATA[<p><strong>vagrant</strong>是一款用来构建虚拟开发环境的工具，非常适合各类开发语言的web应用，因统一安装本地开发环境浪费的人力成本及时间成本，以及不可避免的“work on my machine”错误，将永久告别～  </p>
<h2 id="安装virtualbox及vagrant"><a href="#安装virtualbox及vagrant" class="headerlink" title="安装virtualbox及vagrant"></a>安装virtualbox及vagrant</h2><p>vagrant对virtualbox支持的非常好。但不匹配的版本，加载box会发生或多或少的问题。    </p>
<p>我的工作环境的软件版本是：<br>vagrant 1.6.3<br>virtualbox 4.2.12-84980</p>
<h2 id="添加镜像"><a href="#添加镜像" class="headerlink" title="添加镜像"></a>添加镜像</h2><p>安装好后运行以下命令可以添加vagrant官方的box镜像。  </p>
<pre><code>$ vagrant box add hashicorp/precise64
</code></pre>
<p>这是一个标准的64bit的ubuntu系统。<br>如果要下载其他系统的镜像，可以在这里下载:<a href="https://atlas.hashicorp.com/boxes/search">https://atlas.hashicorp.com/boxes/search</a>   </p>
<h2 id="初始化开发环境"><a href="#初始化开发环境" class="headerlink" title="初始化开发环境"></a>初始化开发环境</h2><p>切换到box文件所在目录，加载box文件及初始化 </p>
<pre><code>$ cd ~/dev 
$ vagrant box add test test.box 
$ vagrant init test
$ vagrant up
</code></pre>
<h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><p>mac下ssh登录，虚拟机目录 /vagrant 就是宿主机的 ~/dev  </p>
<pre><code>$ vagrant ssh
$ cd /vagrant
</code></pre>
<p><strong>windows用户注意:</strong> windows终端需要使用ssh客户端，比如putty等。</p>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>vagrant 初始化成功后，会在初始化的目录里生成一个 vagrantfile 的配置文件，可以修改配置文件进行个性化的定制。  </p>
<p>vagrant 默认是使用端口映射的方式将虚拟机的端口映射本地从而实现类似 <a href="http://localhost/">http://localhost:80</a> 这种访问方式。<br>相比之下，host-only模式显得非常方便。打开 vagrantfile，将下面的注释去掉，便可以访问192.168.33.10机器上的服务了。 </p>
<pre><code>config.vm.network &quot;private_network&quot;, ip:&quot;192.168.33.10&quot;
</code></pre>
<h2 id="打包分发"><a href="#打包分发" class="headerlink" title="打包分发"></a>打包分发</h2><p>当配置好开发环境后，退出并关闭虚拟机。对开发环境进行打包。</p>
<pre><code>$ vagrant package
</code></pre>
<p>打包后，就会在当前目录下生成一个 package.box 的文件。可以分发这个文件给其他开发者。</p>
<h2 id="集成预安装"><a href="#集成预安装" class="headerlink" title="集成预安装"></a>集成预安装</h2><p>vagrant 还提供预安装定制，打开 vagrantfile, 可以放开这些在文件末尾处有被注释的代码：</p>
<pre><code>config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL
    apt-get update
    apt-get install -y apache2
SHELL
</code></pre>
<p>可以把需要安装的软件应用全部写在里面，在初次 vagrant up 的时候，虚拟机会预先执行这些命令。  </p>
<p>如果不是初次运行，但又修改了这些命令。则可以进行重载vagrant。  </p>
<pre><code>$ vagrant reload --provision
</code></pre>
<p>也可以把这些配置写在shell脚本里面，让vagrant加载运行这些脚本。因此整个团队可以维护一个 vagrantfile 或者 shell 脚本，把这个文件放在github上，还可以监控它的版本，多么简单和容易啊！哈哈</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>$ vagrant init  # 初始化
$ vagrant up  # 启动
$ vagrant halt  # 关闭
$ vagrant reload  # 重启
$ vagrant ssh  # ssh
$ vagrant status  # 查看状态
$ vagrant destroy  # 销毁
</code></pre>
]]></content>
      <tags>
        <tag>vagrant</tag>
        <tag>跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title>flask-migrate数据库迁移</title>
    <url>/2016/08/11/flask-migrate%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>在迭代开发中，会阶段性的变更数据库模型，更新数据库。<br>变更时，为了不丢失数据库中的数据，可以使用数据库迁移工具。  </p>
<p><strong>flask－migrate</strong>是对Alembic的轻量级封装，并且已经被集成到了flask-script中。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ pip install flask-migrate
</code></pre>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>from flask_sqlalchemy import SQLAlchemy as SQLAlchemy
from flask_script import Manager, Shell
from flask_migrate import Migrate, MigrateCommand

app = Flask(__name__)
manager = Manager(app)
db = SQLAlchemy(app)
migrate = Migrate(app, db)

manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))
manager.add_command(&#39;db&#39;, MigrateCommand)

if __name__ == &#39;__main__&#39;:
    manager.run()
    
</code></pre>
<h2 id="创建迁移仓库"><a href="#创建迁移仓库" class="headerlink" title="创建迁移仓库"></a>创建迁移仓库</h2><pre><code>$ python xxx.py db init
</code></pre>
<h2 id="创建迁移脚本"><a href="#创建迁移脚本" class="headerlink" title="创建迁移脚本"></a>创建迁移脚本</h2><pre><code>$ python xxx.py db migrate
</code></pre>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><pre><code>$ python xxx.py db upgrade    
</code></pre>
]]></content>
      <tags>
        <tag>flask</tag>
        <tag>python</tag>
        <tag>flask-migrate</tag>
      </tags>
  </entry>
  <entry>
    <title>认识javascript</title>
    <url>/2016/08/08/%E8%AE%A4%E8%AF%86javascript/</url>
    <content><![CDATA[<h2 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h2><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul>
<li>声明变量不用var时，该变量为全局变量</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>Number  </li>
<li><em>整型常量</em>(10进制\8进制\16进制)<br>   十六进制以0x或0X开头, 例如: 0x8a<br> 八进制必须以0开头, 例如: 0123<br> 十进制的第一位不能是0(数字0除外), 例如: 123</li>
<li><em>实型常量</em><br>12.32, 193.98, 5E7, 4e5等</li>
<li>Boolean</li>
<li>String  </li>
<li>“abc”，’abc’<br>双引号会搜索引号内的内容是否含有变量，有则输出其值，没有则输出原有内容<br>单引号则不会检测内容，因此效率更高</li>
<li>特殊字符，需要以反斜杠()后跟一个普通字符来表示<br>例如: \r, \n, \t, \b, &#39;</li>
<li>null常量</li>
<li>undefined常量</li>
<li>特殊数值<br>NaN, Infinity(无穷大), isNaN(), isFinite()</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li>&amp;&amp; 逻辑与</li>
<li>|| 逻辑或</li>
<li>! 逻辑非</li>
</ul>
<h2 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h2><pre><code>function Person(name) &#123;
    this.name = name;
&#125;
</code></pre>
<h2 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h2><p>类(函数)也是对象</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><pre><code>var p = new Person(&quot;张三&quot;)
</code></pre>
<h2 id="闭包closure"><a href="#闭包closure" class="headerlink" title="闭包closure"></a>闭包closure</h2><p>函数内部可以直接读取全局变量。  </p>
<pre><code>    var n = 999;
    
    function f1() &#123;
        alert(n);
    &#125;
    
    f1(); // 999
</code></pre>
<p>函数外部无法读取函数内的局部变量。  </p>
<pre><code>    function f1() &#123;
        var n = 999;
    &#125;
    
    alert(n); // error
</code></pre>
<p>利用闭包，从函数外部读取函数内的局部变量。</p>
<pre><code>    function f1() &#123;
        var n = 999;
        
        function f2() &#123;
            alert(n);
        &#125;
        
        return f2;
    &#125;
    
    var result = f1();
    result(); // 999
</code></pre>
<h2 id="作用域scope（上下文）"><a href="#作用域scope（上下文）" class="headerlink" title="作用域scope（上下文）"></a>作用域scope（上下文）</h2><p>上下文对象就是使用this指针，即被调用函数所处的环境。上下文对象在一个函数内部引用调用它的对象本身。  </p>
<pre><code>var someuser = &#123;
    name: &#39;byvoid&#39;,
    func: function() &#123;
        console.log(this.name);
    &#125;
&#125;;

var foo = &#123;
    name: &#39;foobar&#39;
&#125;;

someuser.func(); // byvoid

foo.func = someuser.func;
foo.func(); // foobar

name = &#39;global&#39;;
func = someuser.func;
func(); // globar
</code></pre>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>利用prototype可以扩展js类。  </p>
<pre><code>Number.prototype.add = function(v) &#123;
    return this + v;
&#125;    

var d = 6;
d.add(8).add(9); // d = 6 + 8 + 9
</code></pre>
<p>扩展自定义的类。</p>
<pre><code>function Person(name) &#123;
    this.name = name;
&#125;

Person.prototype.sayHello = function() &#123;
    alert(this.name);
&#125;

var p = new Person(&quot;zhangsan&quot;);
p.sayHello();
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>classB继承classA</p>
<pre><code>function classA(name) &#123;
    this.name = name;
    this.sayHello = function() &#123;
        alert(this.name);
    &#125;
&#125;
</code></pre>
<p>方法1</p>
<pre><code>function classB(name) &#123;
    this.tempMethod = classA;
    this.tempMethod(name);
&#125;
</code></pre>
<p>方法2</p>
<pre><code>function classB(name) &#123;
    classA.call(this, name);
&#125;
</code></pre>
<p>方法3</p>
<pre><code>function classB(name) &#123;
    classA.apply(this, [name]);
&#125;
</code></pre>
<p>调用classB</p>
<pre><code>var b = new classB(&quot;lisa&quot;);
b.sayHello();
</code></pre>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在js的世界里，内置属性arguments可以接收可辨参数。</p>
<pre><code>function sum() &#123;
    var s = 0;
    for(var i = 0; i &lt; arguments.length; i++) &#123;
        s+ = arguments[i];
    &#125;
    
    return s;
&#125;

alert(sum(1,4,5));
alert(sum(12,15,19,21,51));
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>react native与webapi交互</title>
    <url>/2016/08/08/react-native%E4%B8%8Ewebapi%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>react native坑太大了！！！<br>既然跳进去了，就想办法填坑呗～</p>
<h2 id="webapi"><a href="#webapi" class="headerlink" title="webapi"></a>webapi</h2><h4 id="本地开启webAPI"><a href="#本地开启webAPI" class="headerlink" title="本地开启webAPI"></a>本地开启webAPI</h4><p><img src="http://obksgg9lx.bkt.clouddn.com/webapi.png" alt="webapi"></p>
<h4 id="curl测试webAPI"><a href="#curl测试webAPI" class="headerlink" title="curl测试webAPI"></a>curl测试webAPI</h4><p><img src="http://obksgg9lx.bkt.clouddn.com/getToken.png" alt="test webapi"></p>
<h2 id="react-native如何debug"><a href="#react-native如何debug" class="headerlink" title="react native如何debug"></a>react native如何debug</h2><h4 id="command-d"><a href="#command-d" class="headerlink" title="command + d"></a>command + d</h4><p>在ios的simulator上，command+d调出菜单，选择Debug JS Remotely</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/debugJS.png" alt="debug">  </p>
<h4 id="Runtime-is-not-ready-for-debugging"><a href="#Runtime-is-not-ready-for-debugging" class="headerlink" title="Runtime is not ready for debugging."></a>Runtime is not ready for debugging.</h4><p>如果报出该错，则需要下载chrome浏览器，mac自带的safari无法载入本地的reactJS文件。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/debugging.png" alt="error"></p>
<h4 id="Network-request-failed"><a href="#Network-request-failed" class="headerlink" title="Network request failed."></a>Network request failed.</h4><p>如果报出该错，需要配置xcode里对于http请求的设置。  </p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/networkRequestFail.png" alt="error"></p>
<p>这个错误搞的我烦躁了一个周末，根本没有头绪。<br>首先，要确认RCTWebSocketExecutor.m文件中host = @”localhost”;</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/RCTWebSocketExecutor.png" alt="host"></p>
<p>其次，要在plist的APP Transport Security Settings中添加Allow Arbitrary Loads为True。这个设置把request请求不仅仅局限于https安全模式，http也被允许了。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/plist.png" alt="plist"></p>
<h4 id="chrome-debug"><a href="#chrome-debug" class="headerlink" title="chrome debug"></a>chrome debug</h4><p>测试一下，与本地webapi的交互，在chrome浏览器下可以打断点，查看变量了。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/chromeTool.png" alt="chrome"></p>
<p>webapi的监听也收到了request。</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/requestForWebAPI.png" alt="webapi listen"></p>
<h2 id="退出debug模式"><a href="#退出debug模式" class="headerlink" title="退出debug模式"></a>退出debug模式</h2><h4 id="command-d-1"><a href="#command-d-1" class="headerlink" title="command + d"></a>command + d</h4><p>在ios的simulator上，command+d调出菜单，选择Stop Remote JS Debugging</p>
<p><img src="http://obksgg9lx.bkt.clouddn.com/debugJSStop.png" alt="stop debug"></p>
<p>参照<a href="http://facebook.github.io/react-native/releases/0.31/docs/debugging.html#debugging">facebook debugging文档</a></p>
]]></content>
      <tags>
        <tag>react native</tag>
        <tag>Runtime is not ready for debugging</tag>
        <tag>Network request failed</tag>
      </tags>
  </entry>
  <entry>
    <title>curl测试restful服务</title>
    <url>/2016/07/19/curl%E6%B5%8B%E8%AF%95restful%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>利用curl，可以很方便的测试restful服务，发送HTTP GET，POST，PUT，DELETE请求。也可以改变HTTP header来指定特别条件。</p>
<h3 id="curl参数"><a href="#curl参数" class="headerlink" title="curl参数"></a>curl参数</h3><blockquote>
<p>-X/–request [GET|POST|PUT|DELETE|…]  <mark>指定http request方式</mark><br>-H/–header                             <mark>设定request请求的header</mark><br>-i/–include                            <mark>显示response响应的header</mark><br>-d/–data                               <mark>设定request的参数</mark><br>-v/–verbose                            <mark>输出更多的信息</mark><br>-u/–user                               <mark>使用者账号，密码</mark><br>-b/–cookie                             <mark>cookie</mark></p>
</blockquote>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><pre><code>$ curl -i http://localhost:5000/rest/api/v1.0/tasks
</code></pre>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><pre><code>$ curl -i -H &quot;Content-Type: application/json&quot; -X POST -d &#39;&#123;&quot;title&quot;:&quot;learn python&quot;&#125;&#39; http://localhost:5000/rest/api/v1.0/tasks  
</code></pre>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><pre><code>$ curl -i -H &quot;Content-Type: application/json&quot; -X PUT -d &#39;&#123;&quot;title&quot;:&quot;learn nodejs&quot;&#125;&#39; http://localhost:5000/rest/api/v1.0/tasks/2
</code></pre>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><pre><code>$ curl -i -X DELETE http://localhost:5000/rest/api/v1.0/tasks/1
</code></pre>
]]></content>
      <tags>
        <tag>curl</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS下配置Virtualenv+Flask+Gunicorn+Supervisor+Nginx</title>
    <url>/2016/07/18/centOS%E4%B8%8B%E9%85%8D%E7%BD%AEVirtualenv-Flask-Gunicorn-Supervisor-Nginx/</url>
    <content><![CDATA[<p>在阿里云上部署flask环境。  </p>
<h2 id="安装virtualenv并创建工程"><a href="#安装virtualenv并创建工程" class="headerlink" title="安装virtualenv并创建工程"></a>安装virtualenv并创建工程</h2><pre><code>$ pip install virtualenv
$ virtualenv stooge
$ cd stooge
$ source bin/activate
</code></pre>
<h2 id="安装flask并创建一个服务"><a href="#安装flask并创建一个服务" class="headerlink" title="安装flask并创建一个服务"></a>安装flask并创建一个服务</h2><pre><code>$ pip install flask
$ touch runserver.py
$ vim runserver.py
$ chmod a+x runserver.py
    
</code></pre>
<h3 id="runserver-py"><a href="#runserver-py" class="headerlink" title="runserver.py"></a>runserver.py</h3><pre><code>from flask import Flask

app = Flask(__name__)

@app.route(&#39;/&#39;)
def hello_world():
    return &#39;Hello World!&#39;

if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre>
<h2 id="安装Gunicorn"><a href="#安装Gunicorn" class="headerlink" title="安装Gunicorn"></a>安装Gunicorn</h2><p> Gunicorn是一个开源Python WSGI UNIX的HTTP服务器，默认是同步工作，支持Gevent，Eventlet异步。  </p>
<pre><code>$ pip install gunicorn
</code></pre>
<h3 id="gunicorn-conf"><a href="#gunicorn-conf" class="headerlink" title="gunicorn.conf"></a>gunicorn.conf</h3><p>在项目stooge根目录下, 配置gevent workers数处理并发，及绑定本地的端口号。 </p>
<pre><code>#worker process number
workers = 3
#bind local port
bind = &#39;127.0.0.1:8000&#39;
</code></pre>
<h2 id="安装Supervisor"><a href="#安装Supervisor" class="headerlink" title="安装Supervisor"></a>安装Supervisor</h2><pre><code>$ sudo pip install supervisor
</code></pre>
<p>supervisor是用python实现的一款进程管理工具。supervisor会帮你把管理的应用程序转成daemon程序，而且可以方便的通过命令开启，关闭，重启等操作。而且它管理的进程一旦崩溃会自动重启，这样就可以保证程序在执行中断后自我修复。  </p>
<h3 id="supervisor配置"><a href="#supervisor配置" class="headerlink" title="supervisor配置"></a>supervisor配置</h3><p>supervisor包括两部分：   </p>
<ul>
<li>supervisord  (server端)</li>
<li>supervisorctl  (client端)</li>
</ul>
<p>重定向配置文件  </p>
<pre><code>$ sudo echo_supervisord_conf &gt; /etc/supervisord.conf
</code></pre>
<p>虽然可以把所有的配置项都写到supervisord.conf文件里，但并不推荐这样做。而是通过include的方式把不同的程序组写到不同的配置文件里。  </p>
<p>修改supervisord.conf的include section  </p>
<pre><code>[include]
files = /etc/supervisor/conf.d/*.conf
</code></pre>
<p>添加program配置  </p>
<p>新建目录/etc/supervisor/conf.d，并创建stooge.conf</p>
<pre><code>$ touch stooge.conf
$ vim stooge.conf
[program:stooge]
command=/home/$username/stooge/bin/gunicorn runserver:app -c /home/$username/stooge/gunicorn.conf
directory=/home/$username/stooge
user=$username
autostart=true
autorestart=true
stdout_logfile=/home/$username/stooge/logs/gunicorn_supervisor.log
</code></pre>
<p>这样的配置，通过[program:stooge]来告诉supervisord需要管理哪个进程。可以在client端(supervisorctl或web页面)显示，并对该进程start,restart,stop。</p>
<h3 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="supervisorctl"></a>supervisorctl</h3><p>supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定配置文件。  </p>
<pre><code>$ supervisord -c /etc/supervisord.conf
</code></pre>
<p>shell 命令  </p>
<pre><code>$ supervisorctl status #查看程序状态
$ supervisorctl stop stooge
$ supervisorctl start stooge
$ supervisorctl restart stooge
$ supervisorctl reread #读取有更新的配置文件
$ supervisorctl update #重启配置文件修改过的进程
</code></pre>
<p>在这里我们启动stooge  </p>
<pre><code>$ supervisorctl start stooge
</code></pre>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><pre><code>$ yum install nginx
</code></pre>
<p>centos7下的nginx1.6.3没有sites-available和sites-enabled子目录。但是有conf.d子目录。和配置supervisord一样，也是可以通过include的方式把不同的程序组写到不同的配置文件里。</p>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>确保/etc/nginx/nginx.conf中，http模块中引入conf.d子目录。  </p>
<pre><code>include /etc/nginx/conf.d/*.conf
</code></pre>
<p>在/etc/nginx/conf.d下创建stooge.conf  </p>
<pre><code>server &#123;
    listen 80;
    server_name xx.xx.xx.xx;
    
    root /home/$username/stooge/;
    access_log /home/$username/stooge/access.log;
    error_log /home/$username/stooge/error.log;
    
    location / &#123;
        proxy_set_header X-Forword-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        if (!-f $request_filename) &#123;
            proxy_pass http://127.0.0.1:8000;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>重启nginx服务  </p>
<pre><code>$sudo service nginx restart
</code></pre>
<h2 id="配置firewalld"><a href="#配置firewalld" class="headerlink" title="配置firewalld"></a>配置firewalld</h2><p>安装完nginx后，80端口是没有开放的，外网无法访问。<br>增加http,https到/etc/firewalld/zones/public.xml文件。  </p>
<pre><code>&lt;service name=&quot;http&quot;/&gt;
&lt;service name=&quot;https&quot;/&gt;
</code></pre>
<h2 id="访问helloworld服务"><a href="#访问helloworld服务" class="headerlink" title="访问helloworld服务"></a>访问helloworld服务</h2><p>外网访问ip，显示helloworld了！</p>
]]></content>
      <tags>
        <tag>centOS</tag>
        <tag>Virtualenv</tag>
        <tag>flask</tag>
        <tag>Gunicorn</tag>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>react native初体验</title>
    <url>/2016/07/07/react-native%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>今天想体验一下react native</p>
<pre><code>$ brew install node
$ brew install watchman
$ brew install flow
$ sudo npm install -g react-native-cli
</code></pre>
<p>结果报错如下</p>
<pre><code>$ network getaddrinfo ENOTFOUND registry.npmjs.org registry.npmjs.org:443
</code></pre>
<p>给npm设置proxy翻墙安装就成功了。</p>
<pre><code>$ npm config set proxy http://address:8080
</code></pre>
<p>初始化一个project</p>
<pre><code>$ react-native init HelloWorld
</code></pre>
<p>成功后，新new的project里，会建立好ios和android的初始工程。<br>运行IOS应用程序：</p>
<pre><code>$ react-native run-ios
</code></pre>
<p>运行Android应用程序：</p>
<pre><code>$ react-native run-android
</code></pre>
<p>IOS环境配置很快啊，只要网络没有问题，就很快可以run成功。<br>Android环境配了三天啊。。。各种坑，各种查资料，还好最后也run好了。</p>
<p>开始实战吧。</p>
]]></content>
      <tags>
        <tag>react native</tag>
        <tag>npmjs.org:443</tag>
      </tags>
  </entry>
  <entry>
    <title>js七牛上传实践</title>
    <url>/2016/06/24/js%E4%B8%83%E7%89%9B%E4%B8%8A%E4%BC%A0%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<ul>
<li>七牛有免费的配额可以使用，在测试开发时，将图片，视频流等多种媒体文件可以上传到七牛上。  </li>
<li>其次，七牛可以绕过搭载应用的server，手机端或者pc端可以直接上传下载媒体资源至七牛云。只是在上传时，需要先向应用server要求访问七牛的token，拿到这个token后直接与七牛交互。  </li>
<li>最后，七牛云支持cdn加速，即使对成熟的应用来说，也是不错的选择。 </li>
</ul>
<p><img src="http://developer.qiniu.com/article/developer/img/upload-with-callback.png" alt="七牛"></p>
<p>下面讲解flask作为业务服务器，进行七牛云存储的过程。  </p>
]]></content>
      <tags>
        <tag>flask</tag>
        <tag>js</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title>shell反向删除文件</title>
    <url>/2016/06/24/shell%E5%8F%8D%E5%90%91%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>除了filename文件外，全部rm掉。</p>
<pre><code>$ shopt -s extglob
$ rm -rf !(filename)
</code></pre>
]]></content>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>flask.exthook.ExtDeprecationWarning警告的消除</title>
    <url>/2016/06/17/flask-exthook-ExtDeprecationWarning%E8%AD%A6%E5%91%8A%E7%9A%84%E6%B6%88%E9%99%A4/</url>
    <content><![CDATA[<p>flask升级到0.11版后，弃用了以 <strong>flask.ext.xxx</strong> 导入扩展模块的形式，改为 <strong>flask_xxx</strong>。<br>如果仍然沿用原来的形式，flask会报警告flask.exthook.ExtDeprecationWarning。  </p>
<p>flask团队提供了<a href="https://github.com/pallets/flask-ext-migrate">flask-ext-migrate</a>的转换工具。  </p>
<p>pip安装：  </p>
<pre><code>$ pip install flask-ext-migrate
</code></pre>
<p>转换：  </p>
<pre><code>$ flask_ext_migrate xxx.py
</code></pre>
<p><mark>但目前pip上的版本上存在bug，最新的github上fix了这个问题。</mark><br>这个转换工具一次只能转换一个python文件。<br>随便写个shell批量处理吧。  </p>
<pre><code>$ for f in `find . -name &quot;*.py&quot;`
&gt; &#123;
&gt; flask_ext_migrate $f
&gt; &#125;
</code></pre>
]]></content>
      <tags>
        <tag>flask</tag>
        <tag>shell</tag>
        <tag>flask-ext-migrate</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下批量替换文本</title>
    <url>/2016/06/08/mac%E4%B8%8B%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<p>在mac下使用sed与linux下稍微有一些不同。<br>-i 参数可以指定备份源文件名  </p>
<pre><code>sed -i &quot;bk&quot; &quot;s/Cat/Dog/g&quot; example.txt
</code></pre>
<p>替换example.txt文件中的Cat-&gt;Dog时，会生成备份文件example.txtbk。也可以指定不生成备份文件，-i参数为“”。</p>
<p>批量替换命令如下：  </p>
<pre><code>sed -i &quot;&quot; &quot;s/Cat/Dog/g&quot; `grep Cat -rl ./`
</code></pre>
<p>用grep查找出当前文件夹下含有Cat的文件，然后替换成Dog。并且不指定备份文件。</p>
]]></content>
      <tags>
        <tag>mac</tag>
        <tag>sed</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>pip freeze</title>
    <url>/2016/05/31/pip-freeze/</url>
    <content><![CDATA[<p>在本地python开发时，可以生成requirements.txt文件，用于记录所有依赖包及其精确的版本号。  </p>
<pre><code>pip freeze &gt;requirements.txt
</code></pre>
<p>可创建与本地完全一致的副本环境。  </p>
<pre><code>pip install -r requirements.txt
</code></pre>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用virtualenv</title>
    <url>/2016/05/27/%E4%BD%BF%E7%94%A8virtualenv/</url>
    <content><![CDATA[<p>虚拟环境非常有用。可以在系统的python解释器中避免包的混乱和版本的冲突。</p>
<h2 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h2><pre><code>sudo pip install virtualenv
</code></pre>
<h2 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h2><p>在工程文件夹下创建python虚拟环境。创建虚拟环境后，当前文件夹中会出现一个子文件夹，名字为下述命令中指定的参数venv。  </p>
<pre><code>virtualenv venv     
</code></pre>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><pre><code>source venv/bin/activate
</code></pre>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><pre><code>deactivate
</code></pre>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下搭建hexo至github</title>
    <url>/2016/05/22/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E8%87%B3github/</url>
    <content><![CDATA[<p><strong>hexo</strong>是一款基于Node.js的静态博客框架:<a href="https://github.com/hexojs/hexo">hexo github</a></p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><pre><code>brew install node
</code></pre>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><pre><code>npm install -g hexo
hexo init &lt;folder&gt;
npm install
</code></pre>
<h2 id="hexo语法"><a href="#hexo语法" class="headerlink" title="hexo语法"></a>hexo语法</h2><pre><code>hexo new &quot;postName&quot; #新建文章
hexo generate #生成静态页面至public目录
hexo server #本地预览，默认4000端口
hexo deploy ＃发布
</code></pre>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改hexo根目录下的_config.yml文件,xxx为github的账户名称。  </p>
<pre><code>deploy:
  type: git
  repository: https://github.com/xxx/xxx.github.io.git
  branch: master
 
</code></pre>
<p>在github创建xxx.github.io</p>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>个人比较喜欢<a href="https://github.com/litten/hexo-theme-yilia">yilia github</a></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><pre><code>$ hexo d -g
</code></pre>
]]></content>
  </entry>
</search>
